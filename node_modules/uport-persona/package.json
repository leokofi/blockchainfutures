{
  "_args": [
    [
      {
        "raw": "uport-persona@git://github.com/subramanianv/uport-persona.git#hack",
        "scope": null,
        "escapedName": "uport-persona",
        "name": "uport-persona",
        "rawSpec": "git://github.com/subramanianv/uport-persona.git#hack",
        "spec": "git://github.com/subramanianv/uport-persona.git#hack",
        "type": "hosted",
        "hosted": {
          "type": "github",
          "ssh": "git@github.com:subramanianv/uport-persona.git#hack",
          "sshUrl": "git+ssh://git@github.com/subramanianv/uport-persona.git#hack",
          "httpsUrl": "git+https://github.com/subramanianv/uport-persona.git#hack",
          "gitUrl": "git://github.com/subramanianv/uport-persona.git#hack",
          "shortcut": "github:subramanianv/uport-persona#hack",
          "directUrl": "https://raw.githubusercontent.com/subramanianv/uport-persona/hack/package.json"
        }
      },
      "/Users/Subbu/Desktop/blockchainfutures"
    ]
  ],
  "_from": "git://github.com/subramanianv/uport-persona.git#hack",
  "_id": "uport-persona@1.2.5",
  "_inCache": true,
  "_location": "/uport-persona",
  "_phantomChildren": {},
  "_requested": {
    "raw": "uport-persona@git://github.com/subramanianv/uport-persona.git#hack",
    "scope": null,
    "escapedName": "uport-persona",
    "name": "uport-persona",
    "rawSpec": "git://github.com/subramanianv/uport-persona.git#hack",
    "spec": "git://github.com/subramanianv/uport-persona.git#hack",
    "type": "hosted",
    "hosted": {
      "type": "github",
      "ssh": "git@github.com:subramanianv/uport-persona.git#hack",
      "sshUrl": "git+ssh://git@github.com/subramanianv/uport-persona.git#hack",
      "httpsUrl": "git+https://github.com/subramanianv/uport-persona.git#hack",
      "gitUrl": "git://github.com/subramanianv/uport-persona.git#hack",
      "shortcut": "github:subramanianv/uport-persona#hack",
      "directUrl": "https://raw.githubusercontent.com/subramanianv/uport-persona/hack/package.json"
    }
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git://github.com/subramanianv/uport-persona.git#c2b012c7e61e24a656e59ced13112d03953c54f6",
  "_shasum": "c2e5ed685aa714f11cad7488a04aa0ef6c7fb880",
  "_shrinkwrap": null,
  "_spec": "uport-persona@git://github.com/subramanianv/uport-persona.git#hack",
  "_where": "/Users/Subbu/Desktop/blockchainfutures",
  "author": {
    "name": "oed",
    "email": "joel.torstensson@consensys.net",
    "url": "https://consensys.net"
  },
  "bugs": {
    "url": "https://github.com/ConsenSys/uport-persona/issues"
  },
  "contributors": [
    {
      "name": "Christian Lundkvist",
      "email": "christian.lundkvist@consensys.net",
      "url": "http://consensys.net/"
    },
    {
      "name": "Jeff Scott Ward",
      "email": "jeffscottward@consensys.net",
      "url": "http://consensys.net/"
    },
    {
      "name": "Joel Torstensson",
      "email": "joel.torstensson@consensys.net",
      "url": "http://consensys.net/"
    }
  ],
  "dependencies": {
    "bigi": "1.4.2",
    "bitcoinjs-lib": "2.3.0",
    "blockstack-profiles": "git://github.com/subramanianv/blockstack-profiles-js.git",
    "uport-registry": "git://github.com/subramanianv/uport-registry.git#hack"
  },
  "description": "A library for creating, updating and reading attributes and claims on uport personas.",
  "devDependencies": {
    "babel-cli": "^6.10.1",
    "babel-preset-es2015": "^6.9.0",
    "babel-register": "^6.9.0",
    "chai": "^3.5.0",
    "ether-pudding": "^2.0.0",
    "ethereumjs-testrpc": "^2.2.4",
    "ipfsd-ctl": "^0.14.0",
    "jsdoc": "^3.4.0",
    "jsdoc-to-markdown": "^1.3.6",
    "mocha": "^2.5.3",
    "standard": "^8.0.0"
  },
  "gitHead": "c2b012c7e61e24a656e59ced13112d03953c54f6",
  "homepage": "https://github.com/ConsenSys/uport-persona#readme",
  "license": "Apache-2.0",
  "main": "dist/index.js",
  "name": "uport-persona",
  "optionalDependencies": {},
  "readme": "# uPort Persona\nA library for creating, updating and reading attributes and claims on uport personas. It's intended as an easy interface to the uport-registry, allowing developers to focus on the actual data instead of the datastructure of the object stored in the registry. It contains two main classes `Persona` for getting information on a persona, and `MutablePersona` which is a subclass of `Persona` with additional features for updating persona information.\n## Example usage\n### Importing\n```js\nimport { Persona, MutablePersona } from 'uport-persona';\n```\n\n### Basic information viewing\nFor each persona you want to interact with you have to create a separate instance of the Persona class.\n```js\n// the address of the persona you want to interact with\nlet myAddress = \"0x123...\";\nlet ipfsProvider = {\n  host: 'localhost',\n  port: '5001',\n  protocol: 'https',\n  root: ''\n}\nlet persona = new Persona(myAddress, ipfs, web3.currentProvider);\npersona.load().then(() => { ... });\n```\n\nOnce instantiated you can start by getting the current profile:\n```js\nlet profile = persona.getProfile();\n```\nThe `profile` is in JSON format containing all attributes associated with the persona.\n\n### Viewing attestations\nAn attestation, also called a claim is the basic building block of the information associated with a persona. By default all attributes are self signed claims created by the persona that it's associated with. But an attribute can have multiple claims, meaning that several parties have signed it. The claims are in the same format as [blockstack-profiles](https://github.com/blockstack/blockstack-profiles-js).\nTo get all claims associated with the persona:\n```js\nlet claims = persona.getAllClaims();\n```\n\nYou can also get all claims to a specific attribute:\n```js\nlet claims = persona.getClaims(\"MyAttribute\");\n```\n\n### Signing attributes as a third party\nAs a third party you would like to attest to the fact that the given persona has a specific attribute. By signing an attribute you create a claim.\n```js\nlet thirdPartyPrivKey = ...\nlet thirdPartyAddress = \"0x...\";\nlet claim = persona.signAttribute(\"MyAttribute\", thirdPartyPrivKey, thirdPartyAddress);\n```\n\n### Modifying a persona\nTo modify a persona the `MutablePersona` class needs to be used. It's instantiated in the same way as the `Persona` class. An important thing to note is that `MutablePersona` will make changes locally and only write the changes to the blockchain if the method `writeToRegistry` is called.\n```js\n// the address of the persona you want to interact with\nlet myAddress = \"0x123...\";\nlet ipfs = ipfsApi(<hostname>, <port>);\nlet persona = new MutablePersona(myAddress, ipfs, web3.currentProvider);\npersona.load().then(() => { ... });\n```\n\n#### Creating a profile.\nNote that the first thing that needs to be added to a profile is the public signing key. If this is not done the `addAttribute` method will throw an error.\n```js\nlet myPrivSignKey = ...\npersona.setPublicSigningKey(myPrivSignKey)\npersona.addAttribute({ attributeName: attributeValue }, privKey);\n```\n\n#### Adding a claim.\n```js\npersona.addClaim(claim)\n```\n\n#### Write the changes to the blockchain.\nWhile making changes to the persona these changes are only stored in the javascript object. To save the changes to the blockchain the following function needs to be called.\n```js\npersona.writeToRegistry().then((txHash) => { ... });\n```\n\n## Running tests\nSimply run\n```\n$ npm test\n```\n## Documentation\n<a name=\"Persona\"></a>\n\n## Persona\nClass representing a persona.\n\n**Kind**: global class  \n\n* [Persona](#Persona)\n    * _instance_\n        * [.constructor(address, ipfsProvider, web3Provider, [registryAddress])](#Persona+constructor) ⇒ <code>Object</code>\n        * [.loadAttributes()](#Persona+loadAttributes) ⇒ <code>Promise.&lt;JSON, Error&gt;</code>\n        * [.load(claims)](#Persona+load) ⇒ <code>Promise.&lt;JSON, Error&gt;</code>\n        * [.getProfile()](#Persona+getProfile) ⇒ <code>JSON</code>\n        * [.getPublicSigningKey()](#Persona+getPublicSigningKey) ⇒ <code>String</code>\n        * [.getPublicEncryptionKey()](#Persona+getPublicEncryptionKey) ⇒ <code>String</code>\n        * [.getAllClaims()](#Persona+getAllClaims) ⇒ <code>JSON</code>\n        * [.getClaims(attributesName)](#Persona+getClaims) ⇒ <code>JSON</code>\n        * [.signAttribute(attribute, privSignKey, issuerId)](#Persona+signAttribute) ⇒ <code>Object</code>\n        * [.signMultipleAttributes(attribute, privSignKey, issuerId)](#Persona+signMultipleAttributes) ⇒ <code>Array</code>\n    * _static_\n        * [.isTokenValid(token)](#Persona.isTokenValid) ⇒ <code>Boolean</code>\n        * [.privateKeyToPublicKey(privateKey)](#Persona.privateKeyToPublicKey) ⇒ <code>String</code>\n\n<a name=\"Persona+constructor\"></a>\n\n### persona.constructor(address, ipfsProvider, web3Provider, [registryAddress]) ⇒ <code>Object</code>\nClass constructor.\n Creates a new persona object. The registryAddress is an optional argument and if not specified will be set to the default consensys testnet uport-registry.\n\n**Kind**: instance method of <code>[Persona](#Persona)</code>  \n**Returns**: <code>Object</code> - self  \n\n| Param | Type | Default | Description |\n| --- | --- | --- | --- |\n| address | <code>String</code> |  | the address of the persona |\n| ipfsProvider | <code>String</code> |  | an ipfs provider |\n| web3Provider | <code>String</code> |  | web3 provider |\n| [registryAddress] | <code>String</code> | <code>&#x27;0xa9be82e93628abaac5ab557a9b3b02f711c0151c&#x27;</code> | the uport-registry address to use. |\n\n<a name=\"Persona+loadAttributes\"></a>\n\n### persona.loadAttributes() ⇒ <code>Promise.&lt;JSON, Error&gt;</code>\nThis should be the only function used to get attributes from the uport-registry. This can be overridden in\n a subclass.\n\n**Kind**: instance method of <code>[Persona](#Persona)</code>  \n**Returns**: <code>Promise.&lt;JSON, Error&gt;</code> - A promise that returns all claims registered to the persona. Encrypted claims would be included here. Or an Error if rejected.  \n<a name=\"Persona+load\"></a>\n\n### persona.load(claims) ⇒ <code>Promise.&lt;JSON, Error&gt;</code>\nThis function always have to be called before interacting with the persona. This function loads the profile of the persona from the uport-registry into the persona object. The only time this function should not be called is when creating a completely new persona.\n If the Claims argument is given these claims are used instead of loading anything from the uport-registry.\n\n**Kind**: instance method of <code>[Persona](#Persona)</code>  \n**Returns**: <code>Promise.&lt;JSON, Error&gt;</code> - A promise that returns all claims registered to the persona. Encrypted claims would be included here. Or an Error if rejected.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| claims | <code>Object</code> | A list of claims. If argument is not given the persona will load from the registry. |\n\n<a name=\"Persona+getProfile\"></a>\n\n### persona.getProfile() ⇒ <code>JSON</code>\nThis function returns the profile of the persona in JSON format.\n\n**Kind**: instance method of <code>[Persona](#Persona)</code>  \n**Returns**: <code>JSON</code> - profile  \n<a name=\"Persona+getPublicSigningKey\"></a>\n\n### persona.getPublicSigningKey() ⇒ <code>String</code>\nReturns the public signing key of the persona.\n\n**Kind**: instance method of <code>[Persona](#Persona)</code>  \n<a name=\"Persona+getPublicEncryptionKey\"></a>\n\n### persona.getPublicEncryptionKey() ⇒ <code>String</code>\nReturns the public encryption key of the persona, if set.\n\n**Kind**: instance method of <code>[Persona](#Persona)</code>  \n<a name=\"Persona+getAllClaims\"></a>\n\n### persona.getAllClaims() ⇒ <code>JSON</code>\nReturns all claims associated with the persona.\n\n**Kind**: instance method of <code>[Persona](#Persona)</code>  \n**Returns**: <code>JSON</code> - List of claims  \n<a name=\"Persona+getClaims\"></a>\n\n### persona.getClaims(attributesName) ⇒ <code>JSON</code>\nReturns all claims that have the given attribute name.\n\n**Kind**: instance method of <code>[Persona](#Persona)</code>  \n**Returns**: <code>JSON</code> - List of claims  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| attributesName | <code>String</code> | the name of the attribute to check |\n\n<a name=\"Persona+signAttribute\"></a>\n\n### persona.signAttribute(attribute, privSignKey, issuerId) ⇒ <code>Object</code>\nSigns the given attribute to the persona. This method is to be used by third parties who wishes to attest to an attribute of the persona. Note that this does not add anything to the persona, it only returns a signed claim. To add a claim to a persona the addClaim method of MutablePersona has to be used.\n\n**Kind**: instance method of <code>[Persona](#Persona)</code>  \n**Returns**: <code>Object</code> - claim  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| attribute | <code>Object</code> | the attribute to add, in the format {attrName: attr} |\n| privSignKey | <code>String</code> | the private signing key of the attestor |\n| issuerId | <code>String</code> | the address of the attestor (voluntary, to allow finding info on the attestor from uport-registry) |\n\n<a name=\"Persona+signMultipleAttributes\"></a>\n\n### persona.signMultipleAttributes(attribute, privSignKey, issuerId) ⇒ <code>Array</code>\nSame as signAttribute but for a list of attributes.\n\n**Kind**: instance method of <code>[Persona](#Persona)</code>  \n**Returns**: <code>Array</code> - List of claims  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| attribute | <code>Array</code> | the attribute to add, in the format [{attrName: attr},...] |\n| privSignKey | <code>String</code> | the private signing key of the attestor |\n| issuerId | <code>String</code> | the ethereum address of the attestor |\n\n<a name=\"Persona.isTokenValid\"></a>\n\n### Persona.isTokenValid(token) ⇒ <code>Boolean</code>\nA static function for checking if a token is valid.\n\n**Kind**: static method of <code>[Persona](#Persona)</code>  \n\n| Param | Type |\n| --- | --- |\n| token | <code>Object</code> | \n\n<a name=\"Persona.privateKeyToPublicKey\"></a>\n\n### Persona.privateKeyToPublicKey(privateKey) ⇒ <code>String</code>\nA static function for checking if a token is valid.\n\n**Kind**: static method of <code>[Persona](#Persona)</code>  \n**Returns**: <code>String</code> - publicKey  \n\n| Param | Type |\n| --- | --- |\n| privateKey | <code>String</code> | \n\n\n\n<a name=\"MutablePersona\"></a>\n\n## MutablePersona ⇐ <code>[Persona](#Persona)</code>\nClass representing a persona that can be modified.\n\n**Kind**: global class  \n**Extends:** <code>[Persona](#Persona)</code>  \n\n* [MutablePersona](#MutablePersona) ⇐ <code>[Persona](#Persona)</code>\n    * [.writeToRegistry()](#MutablePersona+writeToRegistry) ⇒ <code>Promise.&lt;String, Error&gt;</code>\n    * [.addClaim(claim)](#MutablePersona+addClaim)\n    * [.addClaims(claimList)](#MutablePersona+addClaims)\n    * [.removeClaim(claim)](#MutablePersona+removeClaim)\n    * [.addAttribute(attribute, privSignKey)](#MutablePersona+addAttribute)\n    * [.replaceAttribute(attribute, privSignKey)](#MutablePersona+replaceAttribute)\n    * [.removeAttribute(attribute)](#MutablePersona+removeAttribute)\n    * [.setPublicSigningKey(privSignKey)](#MutablePersona+setPublicSigningKey)\n    * [.setPublicencryptionKey(pubEncKey, privSignKey)](#MutablePersona+setPublicencryptionKey)\n    * [.constructor(address, ipfsProvider, web3Provider, [registryAddress])](#Persona+constructor) ⇒ <code>Object</code>\n    * [.loadAttributes()](#Persona+loadAttributes) ⇒ <code>Promise.&lt;JSON, Error&gt;</code>\n    * [.load(claims)](#Persona+load) ⇒ <code>Promise.&lt;JSON, Error&gt;</code>\n    * [.getProfile()](#Persona+getProfile) ⇒ <code>JSON</code>\n    * [.getPublicSigningKey()](#Persona+getPublicSigningKey) ⇒ <code>String</code>\n    * [.getPublicEncryptionKey()](#Persona+getPublicEncryptionKey) ⇒ <code>String</code>\n    * [.getAllClaims()](#Persona+getAllClaims) ⇒ <code>JSON</code>\n    * [.getClaims(attributesName)](#Persona+getClaims) ⇒ <code>JSON</code>\n    * [.signAttribute(attribute, privSignKey, issuerId)](#Persona+signAttribute) ⇒ <code>Object</code>\n    * [.signMultipleAttributes(attribute, privSignKey, issuerId)](#Persona+signMultipleAttributes) ⇒ <code>Array</code>\n\n<a name=\"MutablePersona+writeToRegistry\"></a>\n\n### mutablePersona.writeToRegistry() ⇒ <code>Promise.&lt;String, Error&gt;</code>\nThis should be the only function ever used to write the persona onto the blockchain. This can be overridden in\n a subclass.\n\n It stores whatever is in this.tokenRecords.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n**Returns**: <code>Promise.&lt;String, Error&gt;</code> - A promise that returns the txHash of the transaction updating the registry. Or an Error if rejected.  \n<a name=\"MutablePersona+addClaim\"></a>\n\n### mutablePersona.addClaim(claim)\nAdd a signed claim to this persona. This should be used to add tokens signed by third parties.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| claim | <code>JSON</code> | the claim to add |\n\n<a name=\"MutablePersona+addClaims\"></a>\n\n### mutablePersona.addClaims(claimList)\nAdd mulitple signed claims to this persona. This should be used to add tokens signed by third parties.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| claimList | <code>JSON</code> | the claims to add |\n\n<a name=\"MutablePersona+removeClaim\"></a>\n\n### mutablePersona.removeClaim(claim)\nRemoves a signed claim from a persona.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| claim | <code>JSON</code> | the claim to remove |\n\n<a name=\"MutablePersona+addAttribute\"></a>\n\n### mutablePersona.addAttribute(attribute, privSignKey)\nAdds a self signed attribute to the persona. Only to be used if you own the privSignKey of this persona.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| attribute | <code>Object</code> | the attribute to add, in the format {attrName: attr} |\n| privSignKey | <code>String</code> | the private signing key of the persona |\n\n<a name=\"MutablePersona+replaceAttribute\"></a>\n\n### mutablePersona.replaceAttribute(attribute, privSignKey)\nRemoves all tokens having the same attribute name as the given attribute and adds the given attribute.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| attribute | <code>Object</code> | the attribute to add, in the format {attrName: attr} |\n| privSignKey | <code>String</code> | the private signing key of the persona |\n\n<a name=\"MutablePersona+removeAttribute\"></a>\n\n### mutablePersona.removeAttribute(attribute)\nRemoves all attributes with the same attribute name as the given attribute.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| attribute | <code>Object</code> | the attribute to add, in the format {attrName: attr} |\n\n<a name=\"MutablePersona+setPublicSigningKey\"></a>\n\n### mutablePersona.setPublicSigningKey(privSignKey)\nSets the public signing key of the persona.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| privSignKey | <code>String</code> | the private signing key of the persona |\n\n<a name=\"MutablePersona+setPublicencryptionKey\"></a>\n\n### mutablePersona.setPublicencryptionKey(pubEncKey, privSignKey)\nSets the public encryption key of the persona.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| pubEncKey | <code>String</code> | the public encryption key of the persona |\n| privSignKey | <code>String</code> | the private signing key of the persona |\n\n<a name=\"Persona+constructor\"></a>\n\n### mutablePersona.constructor(address, ipfsProvider, web3Provider, [registryAddress]) ⇒ <code>Object</code>\nClass constructor.\n Creates a new persona object. The registryAddress is an optional argument and if not specified will be set to the default consensys testnet uport-registry.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n**Returns**: <code>Object</code> - self  \n\n| Param | Type | Default | Description |\n| --- | --- | --- | --- |\n| address | <code>String</code> |  | the address of the persona |\n| ipfsProvider | <code>String</code> |  | an ipfs provider |\n| web3Provider | <code>String</code> |  | web3 provider |\n| [registryAddress] | <code>String</code> | <code>&#x27;0xa9be82e93628abaac5ab557a9b3b02f711c0151c&#x27;</code> | the uport-registry address to use. |\n\n<a name=\"Persona+loadAttributes\"></a>\n\n### mutablePersona.loadAttributes() ⇒ <code>Promise.&lt;JSON, Error&gt;</code>\nThis should be the only function used to get attributes from the uport-registry. This can be overridden in\n a subclass.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n**Returns**: <code>Promise.&lt;JSON, Error&gt;</code> - A promise that returns all claims registered to the persona. Encrypted claims would be included here. Or an Error if rejected.  \n<a name=\"Persona+load\"></a>\n\n### mutablePersona.load(claims) ⇒ <code>Promise.&lt;JSON, Error&gt;</code>\nThis function always have to be called before interacting with the persona. This function loads the profile of the persona from the uport-registry into the persona object. The only time this function should not be called is when creating a completely new persona.\n If the Claims argument is given these claims are used instead of loading anything from the uport-registry.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n**Returns**: <code>Promise.&lt;JSON, Error&gt;</code> - A promise that returns all claims registered to the persona. Encrypted claims would be included here. Or an Error if rejected.  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| claims | <code>Object</code> | A list of claims. If argument is not given the persona will load from the registry. |\n\n<a name=\"Persona+getProfile\"></a>\n\n### mutablePersona.getProfile() ⇒ <code>JSON</code>\nThis function returns the profile of the persona in JSON format.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n**Returns**: <code>JSON</code> - profile  \n<a name=\"Persona+getPublicSigningKey\"></a>\n\n### mutablePersona.getPublicSigningKey() ⇒ <code>String</code>\nReturns the public signing key of the persona.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n<a name=\"Persona+getPublicEncryptionKey\"></a>\n\n### mutablePersona.getPublicEncryptionKey() ⇒ <code>String</code>\nReturns the public encryption key of the persona, if set.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n<a name=\"Persona+getAllClaims\"></a>\n\n### mutablePersona.getAllClaims() ⇒ <code>JSON</code>\nReturns all claims associated with the persona.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n**Returns**: <code>JSON</code> - List of claims  \n<a name=\"Persona+getClaims\"></a>\n\n### mutablePersona.getClaims(attributesName) ⇒ <code>JSON</code>\nReturns all claims that have the given attribute name.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n**Returns**: <code>JSON</code> - List of claims  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| attributesName | <code>String</code> | the name of the attribute to check |\n\n<a name=\"Persona+signAttribute\"></a>\n\n### mutablePersona.signAttribute(attribute, privSignKey, issuerId) ⇒ <code>Object</code>\nSigns the given attribute to the persona. This method is to be used by third parties who wishes to attest to an attribute of the persona. Note that this does not add anything to the persona, it only returns a signed claim. To add a claim to a persona the addClaim method of MutablePersona has to be used.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n**Returns**: <code>Object</code> - claim  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| attribute | <code>Object</code> | the attribute to add, in the format {attrName: attr} |\n| privSignKey | <code>String</code> | the private signing key of the attestor |\n| issuerId | <code>String</code> | the address of the attestor (voluntary, to allow finding info on the attestor from uport-registry) |\n\n<a name=\"Persona+signMultipleAttributes\"></a>\n\n### mutablePersona.signMultipleAttributes(attribute, privSignKey, issuerId) ⇒ <code>Array</code>\nSame as signAttribute but for a list of attributes.\n\n**Kind**: instance method of <code>[MutablePersona](#MutablePersona)</code>  \n**Returns**: <code>Array</code> - List of claims  \n\n| Param | Type | Description |\n| --- | --- | --- |\n| attribute | <code>Array</code> | the attribute to add, in the format [{attrName: attr},...] |\n| privSignKey | <code>String</code> | the private signing key of the attestor |\n| issuerId | <code>String</code> | the ethereum address of the attestor |\n\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ConsenSys/uport-persona.git"
  },
  "scripts": {
    "build": "babel lib -d dist",
    "docs": "jsdoc --destination docs --verbose lib ",
    "gen-readme": "./node_modules/jsdoc-to-markdown/bin/cli.js --template readme-template.hbs lib/*.js > README.md",
    "prebuild": "node_modules/standard/bin/cmd.js",
    "test": "mocha --reporter spec --compilers js:babel-register test/*.js"
  },
  "standard": {
    "ignore": [
      "dist/**"
    ],
    "globals": [
      "describe",
      "it",
      "before",
      "after",
      "should"
    ]
  },
  "version": "1.2.5"
}
