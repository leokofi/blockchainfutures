'use strict';

var Swarm = require('libp2p-swarm');
var WS = require('libp2p-websockets');
var WebRTCStar = require('libp2p-webrtc-star');
var spdy = require('libp2p-spdy');
var secio = require('libp2p-secio');
var PeerInfo = require('peer-info');
var PeerId = require('peer-id');
var EE = require('events').EventEmitter;
var multiaddr = require('multiaddr');
var PeerBook = require('peer-book');
var mafmt = require('mafmt');

exports = module.exports;

var OFFLINE_ERROR_MESSAGE = 'The libp2p node is not started yet';
var IPFS_CODE = 421;

exports.Node = function Node(pInfo, pBook) {
  var _this = this;

  if (!(this instanceof Node)) {
    return new Node(pInfo, pBook);
  }

  if (!pInfo) {
    pInfo = new PeerInfo();
    pInfo.multiaddr.add(multiaddr('/ip4/0.0.0.0/tcp/0'));
  }

  if (!pBook) {
    pBook = new PeerBook();
  }

  this.peerInfo = pInfo;
  this.peerBook = pBook;

  // Swarm
  this.swarm = new Swarm(pInfo);
  this.swarm.connection.addStreamMuxer(spdy);
  this.swarm.connection.reuse();
  this.swarm.connection.crypto(secio.tag, secio.encrypt);

  this.swarm.on('peer-mux-established', function (peerInfo) {
    _this.peerBook.put(peerInfo);
  });

  this.swarm.on('peer-mux-closed', function (peerInfo) {
    _this.peerBook.removeByB58String(peerInfo.id.toB58String());
  });

  var isOnline = false;

  this.start = function (callback) {
    // if we have `webrtc-star` addrs, then add
    // the WebRTCStar transport
    var wstar = new WebRTCStar();
    if (wstar.filter(_this.peerInfo.multiaddrs).length > 0) {
      _this.swarm.transport.add('wstar', wstar);
      wstar.discovery.on('peer', function (peerInfo) {
        _this.discovery.emit('peer', peerInfo);
      });
      _this.swarm.listen(function (err) {
        if (err) {
          return callback(err);
        }
        // WebSockets needs to be added after because
        // it can't have a listener on the browser
        _this.swarm.transport.add('ws', new WS());
        isOnline = true;
        callback();
      });
    } else {
      // if just WebSockets, no thing to listen
      _this.swarm.transport.add('ws', new WS());
      isOnline = true;
      callback();
    }
  };

  this.stop = function (callback) {
    isOnline = false;
    _this.swarm.close(callback);
  };

  this.dialById = function (id, protocol, callback) {
    if (typeof protocol === 'function') {
      callback = protocol;
      protocol = undefined;
    }

    if (!isOnline) {
      return callback(new Error(OFFLINE_ERROR_MESSAGE));
    }
    // NOTE, these dialById only works if a previous dial
    // was made until we have PeerRouting
    // TODO support PeerRouting when it is Ready
    callback(new Error('not implemented yet'));
  };

  this.dialByMultiaddr = function (maddr, protocol, callback) {
    if (typeof protocol === 'function') {
      callback = protocol;
      protocol = undefined;
    }

    if (!isOnline) {
      return callback(new Error(OFFLINE_ERROR_MESSAGE));
    }

    if (typeof maddr === 'string') {
      maddr = multiaddr(maddr);
    }

    if (!mafmt.IPFS.matches(maddr.toString())) {
      return callback(new Error('multiaddr not valid'));
    }

    var ipfsIdB58String = maddr.stringTuples().filter(function (tuple) {
      if (tuple[0] === IPFS_CODE) {
        return true;
      }
    })[0][1];

    var peer = void 0;
    try {
      peer = _this.peerBook.getByB58String(ipfsIdB58String);
    } catch (err) {
      peer = new PeerInfo(PeerId.createFromB58String(ipfsIdB58String));
    }

    peer.multiaddr.add(maddr);
    _this.dialByPeerInfo(peer, protocol, callback);
  };

  this.dialByPeerInfo = function (peer, protocol, callback) {
    if (typeof protocol === 'function') {
      callback = protocol;
      protocol = undefined;
    }
    if (!isOnline) {
      return callback(new Error(OFFLINE_ERROR_MESSAGE));
    }

    _this.swarm.dial(peer, protocol, function (err, conn) {
      if (err) {
        return callback(err);
      }
      _this.peerBook.put(peer);
      callback(null, conn);
    });
  };

  this.hangUpById = function (id, callback) {
    callback(new Error('not implemented yet'));
    // TODO
  };

  this.hangUpByMultiaddr = function (maddr, callback) {
    if (!isOnline) {
      return callback(new Error(OFFLINE_ERROR_MESSAGE));
    }

    if (typeof maddr === 'string') {
      maddr = multiaddr(maddr);
    }

    if (!mafmt.IPFS.matches(maddr.toString())) {
      return callback(new Error('multiaddr not valid'));
    }

    var ipfsIdB58String = maddr.stringTuples().filter(function (tuple) {
      if (tuple[0] === IPFS_CODE) {
        return true;
      }
    })[0][1];

    try {
      var pi = _this.peerBook.getByB58String(ipfsIdB58String);
      _this.hangUpByPeerInfo(pi, callback);
    } catch (err) {
      // already disconnected
      callback();
    }
  };

  this.hangUpByPeerInfo = function (peer, callback) {
    if (!isOnline) {
      return callback(new Error(OFFLINE_ERROR_MESSAGE));
    }

    _this.peerBook.removeByB58String(peer.id.toB58String());
    _this.swarm.hangUp(peer, callback);
  };

  this.handle = function (protocol, handler) {
    return _this.swarm.handle(protocol, handler);
  };

  this.unhandle = function (protocol) {
    return _this.swarm.unhandle(protocol);
  };

  this.discovery = new EE();
  this.routing = null;
  this.records = null;
};