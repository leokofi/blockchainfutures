/*
 * Id is an object representation of a peer Id. a peer Id is a multihash
 */

'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var mh = require('multihashes');
var crypto = require('libp2p-crypto');
var assert = require('assert');

var PeerId = function () {
  function PeerId(id, privKey, pubKey) {
    _classCallCheck(this, PeerId);

    assert(Buffer.isBuffer(id), 'invalid id provided');

    if (pubKey) {
      assert(id.equals(pubKey.hash()), 'inconsistent arguments');
    }

    if (privKey) {
      assert(id.equals(privKey.public.hash()), 'inconsistent arguments');
    }

    if (privKey && pubKey) {
      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments');
    }

    this.id = id;
    this.privKey = privKey;
    this._pubKey = pubKey;
  }

  _createClass(PeerId, [{
    key: 'marshalPubKey',


    // Return the protobuf version of the public key,
    // matching go ipfs formatting
    value: function marshalPubKey() {
      if (this.pubKey) {
        return crypto.marshalPublicKey(this.pubKey);
      }
    }

    // Return the protobuf version of the private key,
    // matching go ipfs formatting

  }, {
    key: 'marshalPrivKey',
    value: function marshalPrivKey() {
      if (this.privKey) {
        return crypto.marshalPrivateKey(this.privKey);
      }
    }

    // pretty print

  }, {
    key: 'toPrint',
    value: function toPrint() {
      return this.toJSON();
    }

    // return the jsonified version of the key, matching the formatting
    // of go-ipfs for its config file

  }, {
    key: 'toJSON',
    value: function toJSON() {
      return {
        id: mh.toB58String(this.id),
        privKey: toB64Opt(this.marshalPrivKey()),
        pubKey: toB64Opt(this.marshalPubKey())
      };
    }

    // encode/decode functions

  }, {
    key: 'toHexString',
    value: function toHexString() {
      return mh.toHexString(this.id);
    }
  }, {
    key: 'toBytes',
    value: function toBytes() {
      return this.id;
    }
  }, {
    key: 'toB58String',
    value: function toB58String() {
      return mh.toB58String(this.id);
    }
  }, {
    key: 'pubKey',
    get: function get() {
      if (this._pubKey) {
        return this._pubKey;
      }

      if (this.privKey) {
        return this.privKey.public;
      }
    }
  }]);

  return PeerId;
}();

exports = module.exports = PeerId;
exports.Buffer = Buffer;

// generation
exports.create = function (opts) {
  opts = opts || {};
  opts.bits = opts.bits || 2048;

  var privKey = crypto.generateKeyPair('RSA', opts.bits);

  return new PeerId(privKey.public.hash(), privKey);
};

exports.createFromHexString = function (str) {
  return new PeerId(mh.fromHexString(str));
};

exports.createFromBytes = function (buf) {
  return new PeerId(buf);
};

exports.createFromB58String = function (str) {
  return new PeerId(mh.fromB58String(str));
};

// Public Key input will be a buffer
exports.createFromPubKey = function (key) {
  var buf = key;
  if (typeof buf === 'string') {
    buf = new Buffer(key, 'base64');
  }
  var pubKey = crypto.unmarshalPublicKey(buf);
  return new PeerId(pubKey.hash(), null, pubKey);
};

// Private key input will be a string
exports.createFromPrivKey = function (key) {
  var buf = key;
  if (typeof buf === 'string') {
    buf = new Buffer(key, 'base64');
  }

  var privKey = crypto.unmarshalPrivateKey(buf);
  return new PeerId(privKey.public.hash(), privKey);
};

exports.createFromJSON = function (obj) {
  var priv = void 0;
  var pub = void 0;

  if (obj.privKey) {
    priv = crypto.unmarshalPrivateKey(new Buffer(obj.privKey, 'base64'));
  }

  if (obj.pubKey) {
    pub = crypto.unmarshalPublicKey(new Buffer(obj.pubKey, 'base64'));
  }

  return new PeerId(mh.fromB58String(obj.id), priv, pub);
};

function toB64Opt(val) {
  if (val) {
    return val.toString('base64');
  }
}