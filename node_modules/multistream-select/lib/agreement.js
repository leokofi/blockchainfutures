'use strict';

var handshake = require('pull-handshake');
var lp = require('pull-length-prefixed');
var pull = require('pull-stream');
var Connection = require('interface-connection').Connection;
var debug = require('debug');
var log = debug('multistream:agreement');
log.error = debug('multistream:agreement:error');

exports.select = function (multicodec, callback, msThreadId) {
  var stream = handshake({
    timeout: 60 * 1000
  }, callback);

  var shake = stream.handshake;

  log('(%s) writing multicodec %s', msThreadId, multicodec);
  writeEncoded(shake, new Buffer(multicodec + '\n'), callback);

  lp.decodeFromReader(shake, function (err, data) {
    if (err) {
      return callback(err);
    }
    var protocol = data.toString().slice(0, -1);

    if (protocol !== multicodec) {
      return callback(new Error('"' + multicodec + '" not supported'), shake.rest());
    }

    log('(%s) received ack: %s', msThreadId, protocol);
    callback(null, shake.rest());
  });

  return stream;
};

exports.handlerSelector = function (rawConn, handlersMap, msThreadId) {
  var cb = function cb(err) {
    // incoming errors are irrelevant for the app
    log.error(err);
  };

  var stream = handshake({
    timeout: 60 * 1000
  }, cb);

  var shake = stream.handshake;

  next();

  function next() {
    lp.decodeFromReader(shake, function (err, data) {
      if (err) {
        return cb(err);
      }
      log('(%s) received: %s', msThreadId, data.toString());
      var protocol = data.toString().slice(0, -1);
      var result = Object.keys(handlersMap).filter(function (id) {
        return id === protocol;
      });
      var key = result && result[0];

      if (key) {
        log('(%s) send ack back of: %s', msThreadId, protocol);
        writeEncoded(shake, data, cb);
        handlersMap[key](new Connection(shake.rest(), rawConn));
      } else {
        log('(%s) not supported protocol: %s', msThreadId, protocol);
        writeEncoded(shake, new Buffer('na\n'));
        next();
      }
    });
  }

  return stream;
};

// prefixes a message with a varint
function encode(msg, cb) {
  var values = Buffer.isBuffer(msg) ? [msg] : [new Buffer(msg)];

  pull(pull.values(values), lp.encode(), pull.collect(function (err, encoded) {
    if (err) {
      return cb(err);
    }
    cb(null, encoded[0]);
  }));
}

function writeEncoded(writer, msg, cb) {
  encode(msg, function (err, msg) {
    if (err) {
      return cb(err);
    }
    writer.write(msg);
  });
}