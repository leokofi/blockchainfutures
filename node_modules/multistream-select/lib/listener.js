'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var lp = require('pull-length-prefixed');
var pull = require('pull-stream');
var varint = require('varint');
var isFunction = require('lodash.isfunction');
var assert = require('assert');
var debug = require('debug');
var log = debug('multistream:listener');
var Connection = require('interface-connection').Connection;

var PROTOCOL_ID = require('./constants').PROTOCOL_ID;
var agrmt = require('./agreement');

module.exports = function () {
  function Listener() {
    var _this = this;

    _classCallCheck(this, Listener);

    this.handlers = {
      ls: function ls(conn) {
        return _this._ls(conn);
      }
    };
  }

  // perform the multistream handshake


  _createClass(Listener, [{
    key: 'handle',
    value: function handle(rawConn, callback) {
      var _this2 = this;

      var msThreadId = getRandomId();
      log('(%s) listener handle conn', msThreadId);

      var selectStream = agrmt.select(PROTOCOL_ID, function (err, conn) {
        if (err) {
          return callback(err);
        }

        var hsConn = new Connection(conn, rawConn);

        var handlerSelector = agrmt.handlerSelector(hsConn, _this2.handlers, msThreadId);

        pull(hsConn, handlerSelector, hsConn);

        callback();
      }, msThreadId);

      pull(rawConn, selectStream, rawConn);
    }

    // be ready for a given `protocol`

  }, {
    key: 'addHandler',
    value: function addHandler(protocol, handler) {
      log('adding handler: %s', protocol);

      assert(isFunction(handler), 'handler must be a function');

      if (this.handlers[protocol]) {
        log('overwriting handler for %s', protocol);
      }

      this.handlers[protocol] = handler;
    }

    // inner function - handler for `ls`

  }, {
    key: '_ls',
    value: function _ls(conn) {
      var protos = Object.keys(this.handlers).filter(function (key) {
        return key !== 'ls';
      });
      var nProtos = protos.length;
      // total size of the list of protocols, including varint and newline
      var size = protos.reduce(function (size, proto) {
        var p = new Buffer(proto + '\n');
        var el = varint.encodingLength(p.length);
        return size + el;
      }, 0);

      var buf = Buffer.concat([new Buffer(varint.encode(nProtos)), new Buffer(varint.encode(size)), new Buffer('\n')]);

      var encodedProtos = protos.map(function (proto) {
        return new Buffer(proto + '\n');
      });
      var values = [buf].concat(encodedProtos);

      pull(pull.values(values), lp.encode(), conn);
    }
  }]);

  return Listener;
}();

function getRandomId() {
  return (~~(Math.random() * 1e9)).toString(36);
}