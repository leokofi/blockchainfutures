'use strict';

var unixfsEngine = require('ipfs-unixfs-engine');
var importer = unixfsEngine.importer;
var exporter = unixfsEngine.exporter;
var UnixFS = require('ipfs-unixfs');
var isStream = require('isstream');
var promisify = require('promisify-es6');
var multihashes = require('multihashes');
var pull = require('pull-stream');
var sort = require('pull-sort');
var toStream = require('pull-stream-to-stream');
var toPull = require('stream-to-pull-stream');

module.exports = function files(self) {
  var createAddPullStream = function createAddPullStream() {
    return pull(pull.map(normalizeContent), pull.flatten(), importer(self._dagS), pull.asyncMap(prepareFile.bind(null, self)));
  };

  return {
    createAddStream: function createAddStream(callback) {
      callback(null, toStream(createAddPullStream()));
    },

    createAddPullStream: createAddPullStream,

    add: promisify(function (data, callback) {
      if (!callback || typeof callback !== 'function') {
        callback = function noop() {};
      }

      pull(pull.values(normalizeContent(data)), importer(self._dagS), pull.asyncMap(prepareFile.bind(null, self)), sort(function (a, b) {
        if (a.path < b.path) return 1;
        if (a.path > b.path) return -1;
        return 0;
      }), pull.collect(callback));
    }),

    cat: promisify(function (hash, callback) {
      if (typeof hash === 'function') {
        return callback(new Error('You must supply a multihash'));
      }

      self._dagS.get(hash, function (err, node) {
        if (err) {
          return callback(err);
        }

        var data = UnixFS.unmarshal(node.data);
        if (data.type === 'directory') {
          return callback(new Error('This dag node is a directory'));
        }

        pull(exporter(hash, self._dagS), pull.collect(function (err, files) {
          if (err) return callback(err);
          callback(null, toStream.source(files[0].content));
        }));
      });
    }),

    get: promisify(function (hash, callback) {
      callback(null, toStream.source(pull(exporter(hash, self._dagS), pull.map(function (file) {
        if (file.content) {
          file.content = toStream.source(file.content);
          file.content.pause();
        }

        return file;
      }))));
    }),

    getPull: promisify(function (hash, callback) {
      callback(null, exporter(hash, self._dagS));
    })
  };
};

function prepareFile(self, file, cb) {
  var bs58mh = multihashes.toB58String(file.multihash);
  self.object.get(file.multihash, function (err, node) {
    if (err) return cb(err);

    cb(null, {
      path: file.path || bs58mh,
      hash: bs58mh,
      size: node.size()
    });
  });
}

function normalizeContent(content) {
  if (!Array.isArray(content)) {
    content = [content];
  }

  return content.map(function (data) {
    // Buffer input
    if (Buffer.isBuffer(data)) {
      data = {
        path: '',
        content: pull.values([data])
      };
    }

    // Readable stream input
    if (isStream.isReadable(data)) {
      data = {
        path: '',
        content: toPull.source(data)
      };
    }

    if (data && data.content && typeof data.content !== 'function') {
      if (Buffer.isBuffer(data.content)) {
        data.content = pull.values([data.content]);
      }

      if (isStream.isReadable(data.content)) {
        data.content = toPull.source(data.content);
      }
    }

    return data;
  });
}