'use strict';

var utils = require('../../utils');
var debug = require('debug');
var log = debug('cli:version');
log.error = debug('cli:version:error');
var fs = require('fs');
var path = require('path');
var glob = require('glob');
var sortBy = require('lodash.sortby');
var pull = require('pull-stream');
var paramap = require('pull-paramap');
var zip = require('pull-zip');
var toPull = require('stream-to-pull-stream');

function checkPath(inPath, recursive) {
  // This function is to check for the following possible inputs
  // 1) "." add the cwd but throw error for no recursion flag
  // 2) "." -r return the cwd
  // 3) "/some/path" but throw error for no recursion
  // 4) "/some/path" -r
  // 5) No path, throw err
  // 6) filename.type return the cwd + filename

  if (!inPath) {
    throw new Error('Error: Argument \'path\' is required');
  }

  if (inPath === '.') {
    inPath = process.cwd();
  }

  if (fs.statSync(inPath).isDirectory() && recursive === false) {
    throw new Error('Error: ' + inPath + ' is a directory, use the \'-r\' flag to specify directories');
  }

  return inPath;
}

module.exports = {
  command: 'add <file>',

  describe: 'Add a file to IPFS using the UnixFS data format',

  builder: {
    recursive: {
      alias: 'r',
      type: 'boolean',
      default: false
    }
  },

  handler: function handler(argv) {
    var inPath = checkPath(argv.file, argv.recursive);
    var index = inPath.lastIndexOf('/') + 1;

    utils.getIPFS(function (err, ipfs) {
      if (err) {
        throw err;
      }

      // TODO: revist when interface-ipfs-core exposes pull-streams
      var createAddStream = function createAddStream(cb) {
        ipfs.files.createAddStream(function (err, stream) {
          cb(err, err ? null : toPull.transform(stream));
        });
      };

      if (typeof ipfs.files.createAddPullStream === 'function') {
        createAddStream = function createAddStream(cb) {
          cb(null, ipfs.files.createAddPullStream());
        };
      }

      createAddStream(function (err, addStream) {
        if (err) {
          throw err;
        }

        glob(path.join(inPath, '/**/*'), function (err, list) {
          if (err) {
            throw err;
          }
          if (list.length === 0) {
            list = [inPath];
          }

          addPipeline(index, addStream, list);
        });
      });
    });
  }
};

function addPipeline(index, addStream, list) {
  pull(zip(pull.values(list), pull(pull.values(list), paramap(fs.stat.bind(fs), 50))), pull.map(function (pair) {
    return {
      path: pair[0],
      isDirectory: pair[1].isDirectory()
    };
  }), pull.filter(function (file) {
    return !file.isDirectory;
  }), pull.map(function (file) {
    return {
      path: file.path.substring(index, file.path.length),
      content: fs.createReadStream(file.path)
    };
  }), addStream, pull.map(function (file) {
    return {
      hash: file.hash,
      path: file.path
    };
  }), pull.collect(function (err, added) {
    if (err) {
      throw err;
    }

    sortBy(added, 'path').reverse().map(function (file) {
      return 'added ' + file.hash + ' ' + file.path;
    }).forEach(function (msg) {
      return console.log(msg);
    });
  }));
}