'use strict';

var bs58 = require('bs58');
var multipart = require('ipfs-multipart');
var debug = require('debug');
var tar = require('tar-stream');
var log = debug('http-api:files');
log.error = debug('http-api:files:error');
var pull = require('pull-stream');
var toPull = require('stream-to-pull-stream');
var pushable = require('pull-pushable');
var EOL = require('os').EOL;
var toStream = require('pull-stream-to-stream');

exports = module.exports;

// common pre request handler that parses the args and returns `key` which is assigned to `request.pre.args`
exports.parseKey = function (request, reply) {
  if (!request.query.arg) {
    return reply("Argument 'key' is required").code(400).takeover();
  }

  try {
    return reply({
      key: new Buffer(bs58.decode(request.query.arg))
    });
  } catch (err) {
    log.error(err);
    return reply({
      Message: 'invalid ipfs ref path',
      Code: 0
    }).code(500).takeover();
  }
};

exports.cat = {
  // uses common parseKey method that returns a `key`
  parseArgs: exports.parseKey,

  // main route handler which is called after the above `parseArgs`, but only if the args were valid
  handler: function handler(request, reply) {
    var key = request.pre.args.key;
    var ipfs = request.server.app.ipfs;

    ipfs.files.cat(key, function (err, stream) {
      if (err) {
        log.error(err);
        return reply({
          Message: 'Failed to cat file: ' + err,
          Code: 0
        }).code(500);
      }

      // hapi is not very clever and throws if no
      // - _read method
      // - _readableState object
      // are there :(
      if (!stream._read) {
        stream._read = function () {};
        stream._readableState = {};
      }
      return reply(stream).header('X-Stream-Output', '1');
    });
  }
};

exports.get = {
  // uses common parseKey method that returns a `key`
  parseArgs: exports.parseKey,

  // main route handler which is called after the above `parseArgs`, but only if the args were valid
  handler: function handler(request, reply) {
    var key = request.pre.args.key;
    var ipfs = request.server.app.ipfs;
    var pack = tar.pack();

    ipfs.files.getPull(key, function (err, stream) {
      if (err) {
        log.error(err);

        reply({
          Message: 'Failed to get file: ' + err,
          Code: 0
        }).code(500);
        return;
      }

      pull(stream, pull.asyncMap(function (file, cb) {
        var header = { name: file.path };
        if (!file.content) {
          header.type = 'directory';
          pack.entry(header);
          cb();
        } else {
          header.size = file.size;
          var packStream = pack.entry(header, cb);
          if (!packStream) {
            // this happens if the request is aborted
            // we just skip things then
            log('other side hung up');
            return cb();
          }
          toStream.source(file.content).pipe(packStream);
        }
      }), pull.onEnd(function (err) {
        if (err) {
          log.error(err);
          pack.emit('error', err);
          pack.destroy();
          return;
        }

        pack.finalize();
      }));

      // the reply must read the tar stream,
      // to pull values through
      reply(pack).header('X-Stream-Output', '1');
    });
  }
};

exports.add = {
  handler: function handler(request, reply) {
    if (!request.payload) {
      return reply('Array, Buffer, or String is required.').code(400).takeover();
    }

    var ipfs = request.server.app.ipfs;
    // TODO: make pull-multipart
    var parser = multipart.reqParser(request.payload);
    var filesParsed = false;

    var fileAdder = pushable();

    parser.on('file', function (fileName, fileStream) {
      var filePair = {
        path: fileName,
        content: toPull(fileStream)
      };
      filesParsed = true;
      fileAdder.push(filePair);
    });

    parser.on('directory', function (directory) {
      fileAdder.push({
        path: directory,
        content: ''
      });
    });

    parser.on('end', function () {
      if (!filesParsed) {
        return reply("File argument 'data' is required.").code(400).takeover();
      }
      fileAdder.end();
    });

    pull(fileAdder, ipfs.files.createAddPullStream(), pull.map(function (file) {
      return {
        Name: file.path ? file.path : file.hash,
        Hash: file.hash
      };
    }), pull.map(function (file) {
      return JSON.stringify(file) + EOL;
    }), pull.collect(function (err, files) {
      if (err) {
        return reply({
          Message: err,
          Code: 0
        }).code(500);
      }

      if (files.length === 0 && filesParsed) {
        return reply({
          Message: 'Failed to add files.',
          Code: 0
        }).code(500);
      }

      reply(files.join('')).header('x-chunked-output', '1').header('content-type', 'application/json');
    }));
  }
};