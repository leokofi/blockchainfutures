'use strict';

var debug = require('debug');
var log = debug('http-api:block');
log.error = debug('http-api:block:error');
var multiaddr = require('multiaddr');

exports = module.exports;

// common pre request handler that parses the args and returns `addr` which is assigned to `request.pre.args`
exports.parseAddrs = function (request, reply) {
  if (!request.query.arg) {
    return reply("Argument 'addr' is required").code(400).takeover();
  }

  try {
    multiaddr(request.query.arg);
  } catch (err) {
    return reply("Argument 'addr' is invalid").code(500).takeover();
  }

  return reply({
    addr: request.query.arg
  });
};

exports.peers = {
  handler: function handler(request, reply) {
    var ipfs = request.server.app.ipfs;
    ipfs.swarm.peers(function (err, peers) {
      if (err) {
        log.error(err);
        return reply({
          Message: err.toString(),
          Code: 0
        }).code(500);
      }

      return reply({
        Strings: peers.map(function (addr) {
          return addr.toString();
        })
      });
    });
  }
};

exports.addrs = {
  handler: function handler(request, reply) {
    var ipfs = request.server.app.ipfs;
    ipfs.swarm.addrs(function (err, peers) {
      if (err) {
        log.error(err);
        return reply({
          Message: err.toString(),
          Code: 0
        }).code(500);
      }

      var addrs = {};
      peers.forEach(function (peer) {
        addrs[peer.id.toB58String()] = peer.multiaddrs.map(function (addr) {
          return addr.toString();
        });
      });

      return reply({
        Addrs: addrs
      });
    });
  }
};

exports.localAddrs = {
  handler: function handler(request, reply) {
    var ipfs = request.server.app.ipfs;
    ipfs.swarm.localAddrs(function (err, addrs) {
      if (err) {
        log.error(err);
        return reply({
          Message: err.toString(),
          Code: 0
        }).code(500);
      }

      return reply({
        Strings: addrs.map(function (addr) {
          return addr.toString();
        })
      });
    });
  }
};

exports.connect = {
  // uses common parseAddr method that returns a `addr`
  parseArgs: exports.parseAddrs,

  // main route handler which is called after the above `parseArgs`, but only if the args were valid
  handler: function handler(request, reply) {
    var addr = request.pre.args.addr;
    var ipfs = request.server.app.ipfs;

    ipfs.swarm.connect(addr, function (err) {
      if (err) {
        log.error(err);
        return reply({
          Message: err.toString(),
          Code: 0
        }).code(500);
      }

      return reply({
        Strings: ['connect ' + addr + ' success']
      });
    });
  }
};

exports.disconnect = {
  // uses common parseAddr method that returns a `addr`
  parseArgs: exports.parseAddrs,

  // main route handler which is called after the above `parseArgs`, but only if the args were valid
  handler: function handler(request, reply) {
    var addr = request.pre.args.addr;
    var ipfs = request.server.app.ipfs;

    ipfs.swarm.disconnect(addr, function (err) {
      if (err) {
        log.error(err);
        return reply({
          Message: err.toString(),
          Code: 0
        }).code(500);
      }

      return reply({
        Strings: ['disconnect ' + addr + ' success']
      });
    });
  }
};