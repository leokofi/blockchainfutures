'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Block = require('ipfs-block');
var isIPFS = require('is-ipfs');
var pull = require('pull-stream');
var mh = require('multihashes');
var traverse = require('pull-traverse');

var DAGNode = require('./dag-node');

module.exports = function () {
  function DAGService(blockService) {
    _classCallCheck(this, DAGService);

    if (!blockService) {
      throw new Error('DAGService requires a BlockService instance');
    }

    this.bs = blockService;
  }

  // add a DAGNode to the service, storing it on the block service


  _createClass(DAGService, [{
    key: 'put',
    value: function put(node, callback) {
      callback = callback || function () {};
      pull(pull.values([node]), this.putStream(callback));
    }
  }, {
    key: 'putStream',
    value: function putStream(callback) {
      return pull(pull.map(function (node) {
        return new Block(node.encoded());
      }), this.bs.putStream(), pull.onEnd(callback));
    }

    // get retrieves a DAGNode, using the Block Service

  }, {
    key: 'get',
    value: function get(key, callback) {
      pull(this.getStream(key), pull.collect(function (err, res) {
        if (err) return callback(err);
        callback(null, res[0]);
      }));
    }
  }, {
    key: 'getStream',
    value: function getStream(key) {
      var normalizedKey = normalizeKey(key);

      if (!normalizedKey) {
        return pull.error(new Error('Invalid Key'));
      }

      return pull(this.bs.getStream(normalizedKey), pull.map(function (block) {
        var node = new DAGNode();
        node.unMarshal(block.data);
        return node;
      }));
    }
  }, {
    key: 'getRecursive',
    value: function getRecursive(key, cb) {
      pull(this.getRecursiveStream(key), pull.collect(cb));
    }

    // Fetches a node and all of the nodes on its links recursively
    // TODO: add depth param

  }, {
    key: 'getRecursiveStream',
    value: function getRecursiveStream(multihash) {
      var _this = this;

      return pull(this.getStream(multihash), pull.map(function (node) {
        return traverse.widthFirst(node, function (node) {
          return pull(pull.values(node.links), pull.map(function (link) {
            return _this.getStream(link.hash);
          }), pull.flatten());
        });
      }), pull.flatten());
    }

    // remove deletes a node with given multihash from the blockService

  }, {
    key: 'remove',
    value: function remove(multihash, cb) {
      if (!multihash) {
        return cb(new Error('Invalid multihash'));
      }

      this.bs.delete(multihash, cb);
    }
  }]);

  return DAGService;
}();

function normalizeKey(key) {
  var res = void 0;
  var isMhash = isIPFS.multihash(key);
  var isPath = isIPFS.path(key);

  if (!isMhash && !isPath) {
    return null;
  }

  if (isMhash) {
    res = key;
  } else if (isPath) {
    res = key.replace('/ipfs/', '');
  }

  if (typeof res === 'string') {
    return mh.fromB58String(res);
  }

  return res;
}