'use strict';

var Id = require('peer-id');
var multiaddr = require('multiaddr');

exports = module.exports = Peer;

function ensureMultiaddr(addr) {
  if (multiaddr.isMultiaddr(addr)) {
    return addr;
  }

  return multiaddr(addr);
}

// Peer represents a peer on the IPFS network
function Peer(peerId) {
  var _this = this;

  if (!(this instanceof Peer)) {
    return new Peer(peerId);
  }

  if (!peerId) {
    this.id = Id.create();
  } else {
    this.id = peerId;
  }

  this.multiaddrs = [];
  var observedMultiaddrs = [];

  this.multiaddr = {};

  this.multiaddr.add = function (addr) {
    addr = ensureMultiaddr(addr);

    var exists = false;
    _this.multiaddrs.some(function (m, i) {
      if (m.equals(addr)) {
        exists = true;
        return true;
      }
    });
    if (!exists) {
      _this.multiaddrs.push(addr);
    }
  };

  // to prevent multiaddr explosion
  this.multiaddr.addSafe = function (addr) {
    addr = ensureMultiaddr(addr);

    var check = false;
    observedMultiaddrs.some(function (m, i) {
      if (m.equals(addr)) {
        _this.multiaddr.add(addr);
        observedMultiaddrs.splice(i, 1);
        check = true;
      }
    });
    if (!check) {
      observedMultiaddrs.push(addr);
    }
  };

  this.multiaddr.rm = function (addr) {
    addr = ensureMultiaddr(addr);

    _this.multiaddrs.some(function (m, i) {
      if (m.equals(addr)) {
        _this.multiaddrs.splice(i, 1);
        return true;
      }
    });
  };

  this.multiaddr.replace = function (existing, fresh) {
    if (!Array.isArray(existing)) {
      existing = [existing];
    }
    if (!Array.isArray(fresh)) {
      fresh = [fresh];
    }
    existing.forEach(function (m) {
      _this.multiaddr.rm(m);
    });
    fresh.forEach(function (m) {
      _this.multiaddr.add(m);
    });
  };

  // TODO: add features to fetch multiaddr using filters
  // look at https://github.com/whyrusleeping/js-mafmt/blob/master/src/index.js
}