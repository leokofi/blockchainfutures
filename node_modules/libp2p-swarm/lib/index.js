'use strict';

var util = require('util');
var EE = require('events').EventEmitter;
var parallel = require('run-parallel');
var contains = require('lodash.contains');

var transport = require('./transport');
var connection = require('./connection');
var dial = require('./dial');
var protocolMuxer = require('./protocol-muxer');
var plaintext = require('./plaintext');

exports = module.exports = Swarm;

util.inherits(Swarm, EE);

function Swarm(peerInfo) {
  var _this = this;

  if (!(this instanceof Swarm)) {
    return new Swarm(peerInfo);
  }

  if (!peerInfo) {
    throw new Error('You must provide a value for `peerInfo`');
  }

  this._peerInfo = peerInfo;

  // transports --
  // { key: transport }; e.g { tcp: <tcp> }
  this.transports = {};

  // connections --
  // { peerIdB58: { conn: <conn> }}
  this.conns = {};

  // {
  //   peerIdB58: {
  //     muxer: <muxer>
  //     conn: <transport socket> // to extract info required for the Identify Protocol
  //   }
  // }
  this.muxedConns = {};

  // { protocol: handler }
  this.protocols = {};

  // { muxerCodec: <muxer> } e.g { '/spdy/0.3.1': spdy }
  this.muxers = {};

  // is the Identify protocol enabled?
  this.identify = false;

  // Crypto details
  this.crypto = plaintext;

  this.transport = transport(this);
  this.connection = connection(this);

  this.availableTransports = function (pi) {
    var addrs = pi.multiaddrs;

    // Only listen on transports we actually have addresses for
    return Object.keys(_this.transports).filter(function (ts) {
      // ipfs multiaddrs are not dialable so we drop them here
      var dialable = addrs.map(function (addr) {
        // webrtc-star needs the /ipfs/QmHash
        if (addr.toString().indexOf('webrtc-star') > 0) {
          return addr;
        }

        if (contains(addr.protoNames(), 'ipfs')) {
          return addr.decapsulate('ipfs');
        }
        return addr;
      });

      return _this.transports[ts].filter(dialable).length > 0;
    });
  };

  // higher level (public) API
  this.dial = dial(this);

  // Start listening on all available transports
  this.listen = function (callback) {
    parallel(_this.availableTransports(peerInfo).map(function (ts) {
      return function (cb) {
        // Listen on the given transport
        _this.transport.listen(ts, {}, null, cb);
      };
    }), callback);
  };

  this.handle = function (protocol, handler) {
    _this.protocols[protocol] = handler;
  };

  this.handle(this.crypto.tag, function (conn) {
    var id = _this._peerInfo.id;
    var wrapped = _this.crypto.encrypt(id, id.privKey, conn);
    return protocolMuxer(_this.protocols, wrapped);
  });

  this.unhandle = function (protocol) {
    if (_this.protocols[protocol]) {
      delete _this.protocols[protocol];
    }
  };

  this.hangUp = function (peerInfo, callback) {
    var key = peerInfo.id.toB58String();
    if (_this.muxedConns[key]) {
      var muxer = _this.muxedConns[key].muxer;
      muxer.end();
      muxer.once('close', function () {
        delete _this.muxedConns[key];
        callback();
      });
    } else {
      callback();
    }
  };

  this.close = function (callback) {
    Object.keys(_this.muxedConns).forEach(function (key) {
      _this.muxedConns[key].muxer.end();
    });

    var transports = _this.transports;

    parallel(Object.keys(transports).map(function (key) {
      return function (cb) {
        parallel(transports[key].listeners.map(function (listener) {
          return function (cb) {
            return listener.close(cb);
          };
        }), cb);
      };
    }), callback);
  };
}