'use strict';

var identify = require('libp2p-identify');
var multistream = require('multistream-select');
var waterfall = require('run-waterfall');
var debug = require('debug');
var log = debug('libp2p:swarm:connection');

var protocolMuxer = require('./protocol-muxer');
var plaintext = require('./plaintext');

module.exports = function connection(swarm) {
  return {
    addUpgrade: function addUpgrade() {},
    addStreamMuxer: function addStreamMuxer(muxer) {
      // for dialing
      swarm.muxers[muxer.multicodec] = muxer;

      // for listening
      swarm.handle(muxer.multicodec, function (conn) {
        var muxedConn = muxer.listener(conn);

        muxedConn.on('stream', function (conn) {
          protocolMuxer(swarm.protocols, conn);
        });

        // If identify is enabled
        //   1. overload getPeerInfo
        //   2. call getPeerInfo
        //   3. add this conn to the pool
        if (swarm.identify) {
          // overload peerInfo to use Identify instead
          conn.getPeerInfo = function (cb) {
            var conn = muxedConn.newStream();
            var ms = new multistream.Dialer();

            waterfall([function (cb) {
              return ms.handle(conn, cb);
            }, function (cb) {
              return ms.select(identify.multicodec, cb);
            }, function (conn, cb) {
              return identify.dialer(conn, cb);
            }, function (peerInfo, observedAddrs, cb) {
              observedAddrs.forEach(function (oa) {
                swarm._peerInfo.multiaddr.addSafe(oa);
              });
              cb(null, peerInfo);
            }], cb);
          };

          conn.getPeerInfo(function (err, peerInfo) {
            if (err) {
              return log('Identify not successful');
            }
            swarm.muxedConns[peerInfo.id.toB58String()] = {
              muxer: muxedConn
            };

            swarm.emit('peer-mux-established', peerInfo);
            muxedConn.on('close', function () {
              delete swarm.muxedConns[peerInfo.id.toB58String()];
              swarm.emit('peer-mux-closed', peerInfo);
            });
          });
        }

        return conn;
      });
    },
    reuse: function reuse() {
      swarm.identify = true;
      swarm.handle(identify.multicodec, function (conn) {
        identify.listener(conn, swarm._peerInfo);
      });
    },
    crypto: function crypto(tag, encrypt) {
      if (!tag && !encrypt) {
        tag = plaintext.tag;
        encrypt = plaintext.encrypt;
      }

      swarm.unhandle(swarm.crypto.tag);
      swarm.handle(tag, function (conn) {
        var id = swarm._peerInfo.id;
        var secure = encrypt(id, id.privKey, conn);

        protocolMuxer(swarm.protocols, secure);
      });

      swarm.crypto = { tag: tag, encrypt: encrypt };
    }
  };
};