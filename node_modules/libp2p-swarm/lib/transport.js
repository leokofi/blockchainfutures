'use strict';

var Connection = require('interface-connection').Connection;
var parallel = require('run-parallel');
var debug = require('debug');
var log = debug('libp2p:swarm:transport');

var protocolMuxer = require('./protocol-muxer');

module.exports = function (swarm) {
  return {
    add: function add(key, transport, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      if (!callback) {
        callback = noop;
      }
      log('adding %s', key);
      if (swarm.transports[key]) {
        throw new Error('There is already a transport with this key');
      }
      swarm.transports[key] = transport;
      if (!swarm.transports[key].listeners) {
        swarm.transports[key].listeners = [];
      }

      callback();
    },
    dial: function dial(key, multiaddrs, callback) {
      var t = swarm.transports[key];

      if (!Array.isArray(multiaddrs)) {
        multiaddrs = [multiaddrs];
      }
      log('dialing %s', key, multiaddrs.map(function (m) {
        return m.toString();
      }));
      // a) filter the multiaddrs that are actually valid for this transport (use a func from the transport itself) (maybe even make the transport do that)
      multiaddrs = dialables(t, multiaddrs);

      // b) if multiaddrs.length = 1, return the conn from the
      // transport, otherwise, create a passthrough
      if (multiaddrs.length === 1) {
        var conn = t.dial(multiaddrs.shift());
        callback(null, new Connection(conn));
        return;
      }

      // c) multiaddrs should already be a filtered list
      // specific for the transport we are using
      var proxyConn = new Connection();

      next(multiaddrs.shift());

      // TODO improve in the future to make all the dials in paralell
      function next(multiaddr) {
        var conn = t.dial(multiaddr, function () {
          proxyConn.setInnerConn(conn);
          callback(null, proxyConn);
        });
      }
    },
    listen: function listen(key, options, handler, callback) {
      // if no handler is passed, we pass conns to protocolMuxer
      if (!handler) {
        handler = protocolMuxer.bind(null, swarm.protocols);
      }

      var multiaddrs = dialables(swarm.transports[key], swarm._peerInfo.multiaddrs);

      var transport = swarm.transports[key];

      if (!transport.listeners) {
        transport.listeners = [];
      }

      var freshMultiaddrs = [];

      var createListeners = multiaddrs.map(function (ma) {
        return function (cb) {
          var listener = transport.createListener(handler);
          listener.listen(ma, function () {
            listener.getAddrs(function (err, addrs) {
              if (err) {
                return cb(err);
              }
              freshMultiaddrs = freshMultiaddrs.concat(addrs);
              transport.listeners.push(listener);
              cb();
            });
          });
        };
      });

      parallel(createListeners, function () {
        // cause we can listen on port 0 or 0.0.0.0
        swarm._peerInfo.multiaddr.replace(multiaddrs, freshMultiaddrs);
        callback();
      });
    },
    close: function close(key, callback) {
      var transport = swarm.transports[key];

      if (!transport) {
        return callback(new Error('Trying to close non existing transport: ' + key));
      }

      parallel(transport.listeners.map(function (listener) {
        return function (cb) {
          listener.close(cb);
        };
      }), callback);
    }
  };
};

function dialables(tp, multiaddrs) {
  return tp.filter(multiaddrs);
}

function noop() {}