'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var forge = require('node-forge');
var protobuf = require('protocol-buffers');
var fs = require('fs');
var path = require('path');

var utils = require('../utils');

var pki = forge.pki;
var rsa = pki.rsa;

var pbm = protobuf(fs.readFileSync(path.join(__dirname, '../crypto.proto')));

var RsaPublicKey = function () {
  function RsaPublicKey(k) {
    _classCallCheck(this, RsaPublicKey);

    this._key = k;
  }

  _createClass(RsaPublicKey, [{
    key: 'verify',
    value: function verify(data, sig) {
      var md = forge.md.sha256.create();
      if (Buffer.isBuffer(data)) {
        md.update(data.toString('binary'), 'binary');
      } else {
        md.update(data);
      }

      return this._key.verify(md.digest().bytes(), sig);
    }
  }, {
    key: 'marshal',
    value: function marshal() {
      return new Buffer(forge.asn1.toDer(pki.publicKeyToAsn1(this._key)).bytes(), 'binary');
    }
  }, {
    key: 'encrypt',
    value: function encrypt(bytes) {
      return this._key.encrypt(bytes, 'RSAES-PKCS1-V1_5');
    }
  }, {
    key: 'equals',
    value: function equals(key) {
      return this.bytes.equals(key.bytes);
    }
  }, {
    key: 'hash',
    value: function hash() {
      return utils.keyHash(this.bytes);
    }
  }, {
    key: 'bytes',
    get: function get() {
      return pbm.PublicKey.encode({
        Type: pbm.KeyType.RSA,
        Data: this.marshal()
      });
    }
  }]);

  return RsaPublicKey;
}();

var RsaPrivateKey = function () {
  function RsaPrivateKey(privKey, pubKey) {
    _classCallCheck(this, RsaPrivateKey);

    this._privateKey = privKey;
    if (pubKey) {
      this._publicKey = pubKey;
    } else {
      this._publicKey = forge.pki.setRsaPublicKey(privKey.n, privKey.e);
    }
  }

  _createClass(RsaPrivateKey, [{
    key: 'genSecret',
    value: function genSecret() {
      return forge.random.getBytesSync(16);
    }
  }, {
    key: 'sign',
    value: function sign(message) {
      var md = forge.md.sha256.create();
      if (Buffer.isBuffer(message)) {
        md.update(message.toString('binary'), 'binary');
      } else {
        md.update(message);
      }
      var raw = this._privateKey.sign(md, 'RSASSA-PKCS1-V1_5');
      return new Buffer(raw, 'binary');
    }
  }, {
    key: 'decrypt',
    value: function decrypt(bytes) {
      return this._privateKey.decrypt(bytes, 'RSAES-PKCS1-V1_5');
    }
  }, {
    key: 'marshal',
    value: function marshal() {
      return new Buffer(forge.asn1.toDer(pki.privateKeyToAsn1(this._privateKey)).bytes(), 'binary');
    }
  }, {
    key: 'equals',
    value: function equals(key) {
      return this.bytes.equals(key.bytes);
    }
  }, {
    key: 'hash',
    value: function hash() {
      return utils.keyHash(this.bytes);
    }
  }, {
    key: 'public',
    get: function get() {
      if (!this._publicKey) {
        throw new Error('public key not provided');
      }

      return new RsaPublicKey(this._publicKey);
    }
  }, {
    key: 'bytes',
    get: function get() {
      return pbm.PrivateKey.encode({
        Type: pbm.KeyType.RSA,
        Data: this.marshal()
      });
    }
  }]);

  return RsaPrivateKey;
}();

function unmarshalRsaPrivateKey(bytes) {
  if (Buffer.isBuffer(bytes)) {
    bytes = forge.util.createBuffer(bytes.toString('binary'));
  }
  var key = pki.privateKeyFromAsn1(forge.asn1.fromDer(bytes));

  return new RsaPrivateKey(key);
}

function unmarshalRsaPublicKey(bytes) {
  if (Buffer.isBuffer(bytes)) {
    bytes = forge.util.createBuffer(bytes.toString('binary'));
  }
  var key = pki.publicKeyFromAsn1(forge.asn1.fromDer(bytes));

  return new RsaPublicKey(key);
}

function generateKeyPair(bits) {
  var p = rsa.generateKeyPair({ bits: bits });
  return new RsaPrivateKey(p.privateKey, p.publicKey);
}

module.exports = {
  RsaPublicKey: RsaPublicKey,
  RsaPrivateKey: RsaPrivateKey,
  unmarshalRsaPublicKey: unmarshalRsaPublicKey,
  unmarshalRsaPrivateKey: unmarshalRsaPrivateKey,
  generateKeyPair: generateKeyPair
};