'use strict';

var forge = require('node-forge');
var createBuffer = forge.util.createBuffer;

var cipherMap = {
  'AES-128': {
    ivSize: 16,
    keySize: 16
  },
  'AES-256': {
    ivSize: 16,
    keySize: 32
  },
  Blowfish: {
    ivSize: 8,
    cipherKeySize: 32
  }
};

var hashMap = {
  SHA1: 'sha1',
  SHA256: 'sha256',
  // workaround for https://github.com/digitalbazaar/forge/issues/401
  SHA512: forge.md.sha512.create()
};

// Generates a set of keys for each party by stretching the shared key.
// (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)
module.exports = function (cipherType, hashType, secret) {
  var cipher = cipherMap[cipherType];
  var hash = hashMap[hashType];

  if (!cipher) {
    throw new Error('unkown cipherType passed');
  }

  if (!hash) {
    throw new Error('unkown hashType passed');
  }

  if (Buffer.isBuffer(secret)) {
    secret = createBuffer(secret.toString('binary'));
  }

  var cipherKeySize = cipher.keySize;
  var ivSize = cipher.ivSize;
  var hmacKeySize = 20;
  var seed = 'key expansion';
  var resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);

  var m = forge.hmac.create();
  m.start(hash, secret);
  m.update(seed);

  var a = m.digest().bytes();
  var result = createBuffer();

  var j = 0;
  for (; j < resultLength;) {
    m.start(hash, secret);
    m.update(a);
    m.update(seed);

    var b = createBuffer(m.digest(), 'raw');
    var todo = b.length();

    if (j + todo > resultLength) {
      todo = resultLength - j;
    }

    result.putBytes(b.getBytes(todo));

    j += todo;

    m.start(hash, secret);
    m.update(a);
    a = m.digest().bytes();
  }

  var half = resultLength / 2;
  var r1 = createBuffer(result.getBytes(half));
  var r2 = createBuffer(result.getBytes());

  var createKey = function createKey(res) {
    return {
      iv: new Buffer(res.getBytes(ivSize), 'binary'),
      cipherKey: new Buffer(res.getBytes(cipherKeySize), 'binary'),
      macKey: new Buffer(res.getBytes(), 'binary')
    };
  };

  return {
    k1: createKey(r1),
    k2: createKey(r2)
  };
};