'use strict';

var debug = require('debug');
var log = debug('libp2p:webrtc-star');
var multiaddr = require('multiaddr');
var mafmt = require('mafmt');
var io = require('socket.io-client');
var EE = require('events').EventEmitter;
var SimplePeer = require('simple-peer');
var peerId = require('peer-id');
var PeerInfo = require('peer-info');
var Connection = require('interface-connection').Connection;
var toPull = require('stream-to-pull-stream');

exports = module.exports = WebRTCStar;

var sioOptions = {
  transports: ['websocket'],
  'force new connection': true
};

function WebRTCStar() {
  var _this = this;

  if (!(this instanceof WebRTCStar)) {
    return new WebRTCStar();
  }

  var maSelf = void 0;
  var listeners = {};
  this.discovery = new EE();

  this.dial = function (ma, options, callback) {
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    if (!callback) {
      callback = function noop() {};
    }

    var intentId = (~~(Math.random() * 1e9)).toString(36) + Date.now();
    var sioClient = listeners[Object.keys(listeners)[0]].io;
    var channel = new SimplePeer({ initiator: true, trickle: false });

    var conn = new Connection(toPull.duplex(channel));
    var connected = false;

    channel.on('signal', function (signal) {
      sioClient.emit('ss-handshake', {
        intentId: intentId,
        srcMultiaddr: maSelf.toString(),
        dstMultiaddr: ma.toString(),
        signal: signal
      });
    });

    channel.on('timeout', function () {
      callback(new Error('timeout'));
    });

    channel.on('error', function (err) {
      if (!connected) {
        callback(err);
      }
    });

    sioClient.on('ws-handshake', function (offer) {
      if (offer.intentId !== intentId || !offer.answer) {
        return;
      }

      channel.on('connect', function () {
        connected = true;
        conn.destroy = channel.destroy.bind(channel);

        channel.on('close', function () {
          conn.destroy();
        });

        conn.getObservedAddrs = function (callback) {
          return callback(null, [ma]);
        };

        callback(null, conn);
      });

      channel.signal(offer.signal);
    });

    return conn;
  };

  this.createListener = function (options, handler) {
    if (typeof options === 'function') {
      handler = options;
      options = {};
    }

    var listener = new EE();

    listener.listen = function (ma, callback) {
      if (!callback) {
        callback = function noop() {};
      }
      maSelf = ma;

      var sioUrl = 'http://' + ma.toString().split('/')[3] + ':' + ma.toString().split('/')[5];

      listener.io = io.connect(sioUrl, sioOptions);
      listener.io.on('connect_error', callback);
      listener.io.on('connect', function () {
        listener.io.emit('ss-join', ma.toString());
        listener.io.on('ws-handshake', incommingDial);
        listener.io.on('ws-peer', peerDiscovered.bind(_this));
        listener.emit('listening');
        callback();
      });

      function incommingDial(offer) {
        if (offer.answer) {
          return;
        }

        var channel = new SimplePeer({ trickle: false });
        var conn = new Connection(toPull.duplex(channel));

        channel.on('connect', function () {
          conn.getObservedAddrs = function (callback) {
            return callback(null, [offer.srcMultiaddr]);
          };

          listener.emit('connection', conn);
          handler(conn);
        });

        channel.on('signal', function (signal) {
          offer.signal = signal;
          offer.answer = true;
          listener.io.emit('ss-handshake', offer);
        });

        channel.signal(offer.signal);
      }
    };

    listener.close = function (callback) {
      if (!callback) {
        callback = function noop() {};
      }
      listener.io.emit('ss-leave');
      setTimeout(function () {
        listener.emit('close');
        callback();
      }, 100);
    };

    listener.getAddrs = function (callback) {
      process.nextTick(function () {
        callback(null, [maSelf]);
      });
    };

    listeners[multiaddr.toString()] = listener;
    return listener;
  };

  this.filter = function (multiaddrs) {
    if (!Array.isArray(multiaddrs)) {
      multiaddrs = [multiaddrs];
    }
    return multiaddrs.filter(function (ma) {
      return mafmt.WebRTCStar.matches(ma);
    });
  };

  function peerDiscovered(maStr) {
    log('Peer Discovered:', maStr);
    var id = peerId.createFromB58String(maStr.split('/')[8]);
    var peer = new PeerInfo(id);
    peer.multiaddr.add(multiaddr(maStr));
    this.discovery.emit('peer', peer);
  }
}