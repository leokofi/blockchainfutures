'use strict';

var config = require('../config');
var log = config.log;
var SocketIO = require('socket.io');

module.exports = function (http) {
  var io = new SocketIO(http.listener);
  io.on('connection', handle);

  var peers = {};

  undefined.peers = function () {
    return peers;
  };

  function safeEmit(addr, event, arg) {
    var peer = peers[addr];
    if (!peer) {
      log('trying to emit %s but peer is gone', event);
      return;
    }

    peer.emit(event, arg);
  }

  function handle(socket) {
    socket.on('ss-join', join.bind(socket));
    socket.on('ss-leave', leave.bind(socket));
    socket.on('disconnect', disconnect.bind(socket)); // socket.io own event
    socket.on('ss-handshake', forwardHandshake);
  }

  // join this signaling server network
  function join(multiaddr) {
    peers[multiaddr] = this; // socket
    Object.keys(peers).forEach(function (mh) {
      if (mh === multiaddr) {
        return;
      }
      safeEmit(mh, 'ws-peer', multiaddr);
    });
  }

  function leave(multiaddr) {
    if (peers[multiaddr]) {
      delete peers[multiaddr];
    }
  }

  function disconnect() {
    var _this = this;

    Object.keys(peers).forEach(function (mh) {
      if (peers[mh].id === _this.id) {
        delete peers[mh];
      }
    });
  }

  // forward an WebRTC offer to another peer
  function forwardHandshake(offer) {
    if (offer.answer) {
      safeEmit(offer.srcMultiaddr, 'ws-handshake', offer);
    } else {
      if (peers[offer.dstMultiaddr]) {
        safeEmit(offer.dstMultiaddr, 'ws-handshake', offer);
      } else {
        offer.err = 'peer is not available';
        safeEmit(offer.srcMultiaddr, 'ws-handshake', offer);
      }
    }
  }

  return undefined;
};