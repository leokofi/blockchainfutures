'use strict';

var through = require('pull-through');
var pull = require('pull-stream');
var lp = require('pull-length-prefixed');

var toForgeBuffer = require('./support').toForgeBuffer;

var lpOpts = {
  fixed: true,
  bytes: 4
};

exports.createBoxStream = function (cipher, mac) {
  var pt = through(function (chunk) {
    cipher.update(toForgeBuffer(chunk));

    if (cipher.output.length() > 0) {
      var data = new Buffer(cipher.output.getBytes(), 'binary');
      mac.update(data.toString('binary'));
      var macBuffer = new Buffer(mac.digest().getBytes(), 'binary');

      this.queue(Buffer.concat([data, macBuffer]));
      // reset hmac
      mac.start(null, null);
    }
  });

  return pull(pt, lp.encode(lpOpts));
};

exports.createUnboxStream = function (decipher, mac) {
  var pt = through(function (chunk) {
    var l = chunk.length;
    var macSize = mac.getMac().length();

    if (l < macSize) {
      return this.emit('error', new Error('buffer (' + l + ') shorter than MAC size (' + macSize + ')'));
    }

    var mark = l - macSize;
    var data = chunk.slice(0, mark);
    var macd = chunk.slice(mark);

    // Clear out any previous data
    mac.start(null, null);

    mac.update(data.toString('binary'));
    var expected = new Buffer(mac.getMac().getBytes(), 'binary');

    // reset hmac
    mac.start(null, null);
    if (!macd.equals(expected)) {
      return this.emit('error', new Error('MAC Invalid: ' + macd.toString('hex') + ' != ' + expected.toString('hex')));
    }

    // all good, decrypt
    decipher.update(toForgeBuffer(data));

    if (decipher.output.length() > 0) {
      var _data = new Buffer(decipher.output.getBytes(), 'binary');
      this.queue(_data);
    }
  });

  return pull(lp.decode(lpOpts), pt);
};