'use strict';

var mh = require('multihashing');
var forge = require('node-forge');
var lp = require('pull-length-prefixed');
var pull = require('pull-stream');

exports.exchanges = ['P-256', 'P-384', 'P-521'];

exports.ciphers = ['AES-256', 'AES-128'];

exports.hashes = ['SHA256', 'SHA512'];

// Determines which algorithm to use.  Note:  f(a, b) = f(b, a)
exports.theBest = function (order, p1, p2) {
  var first = void 0;
  var second = void 0;

  if (order < 0) {
    first = p2;
    second = p1;
  } else if (order > 0) {
    first = p1;
    second = p2;
  } else {
    return p1[0];
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = first[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var firstCandidate = _step.value;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = second[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var secondCandidate = _step2.value;

          if (firstCandidate === secondCandidate) {
            return firstCandidate;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  throw new Error('No algorithms in common!');
};

exports.makeMacAndCipher = function (target) {
  target.mac = makeMac(target.hashT, target.keys.macKey);
  target.cipher = makeCipher(target.cipherT, target.keys.iv, target.keys.cipherKey);
};

var hashMap = {
  SHA1: 'sha1',
  SHA256: 'sha256',
  // workaround for https://github.com/digitalbazaar/forge/issues/401
  SHA512: forge.md.sha512.create()
};

var toForgeBuffer = exports.toForgeBuffer = function (buf) {
  return forge.util.createBuffer(buf.toString('binary'));
};

function makeMac(hashType, key) {
  var hash = hashMap[hashType];

  if (!hash) {
    throw new Error('unsupported hash type: ' + hashType);
  }

  var mac = forge.hmac.create();
  mac.start(hash, toForgeBuffer(key));
  return mac;
}

function makeCipher(cipherType, iv, key) {
  if (cipherType === 'AES-128' || cipherType === 'AES-256') {
    // aes in counter (CTR) mode because that is what
    // is used in go (cipher.NewCTR)
    var cipher = forge.cipher.createCipher('AES-CTR', toForgeBuffer(key));
    cipher.start({ iv: toForgeBuffer(iv) });
    return cipher;
  }

  // TODO: Blowfish is not supported in node-forge, figure out if
  // it's needed and if so find a library for it.

  throw new Error('unrecognized cipher type: ' + cipherType);
}

exports.randomBytes = function (nonceSize) {
  return new Buffer(forge.random.getBytesSync(nonceSize), 'binary');
};

exports.selectBest = function (local, remote) {
  var oh1 = exports.digest(Buffer.concat([remote.pubKeyBytes, local.nonce]));
  var oh2 = exports.digest(Buffer.concat([local.pubKeyBytes, remote.nonce]));
  var order = Buffer.compare(oh1, oh2);

  if (order === 0) {
    throw new Error('you are trying to talk to yourself');
  }

  return {
    curveT: exports.theBest(order, local.exchanges, remote.exchanges),
    cipherT: exports.theBest(order, local.ciphers, remote.ciphers),
    hashT: exports.theBest(order, local.hashes, remote.hashes),
    order: order
  };
};

exports.digest = function (buf) {
  return mh.digest(buf, 'sha2-256', buf.length);
};

exports.write = function write(state, msg, cb) {
  cb = cb || function () {};
  pull(pull.values([msg]), lp.encode({ fixed: true, bytes: 4 }), pull.collect(function (err, res) {
    if (err) {
      return cb(err);
    }
    state.shake.write(res[0]);
    cb();
  }));
};

exports.read = function read(reader, cb) {
  lp.decodeFromReader(reader, { fixed: true, bytes: 4 }, cb);
};