'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var protobuf = require('protocol-buffers');
var fs = require('fs');
var Block = require('ipfs-block');
var path = require('path');
var isEqualWith = require('lodash.isequalwith');
var mh = require('multihashes');
var assert = require('assert');

var pbm = protobuf(fs.readFileSync(path.join(__dirname, 'message.proto')));
var Entry = require('./entry');

var BitswapMessage = function () {
  function BitswapMessage(full) {
    _classCallCheck(this, BitswapMessage);

    this.full = full;
    this.wantlist = new Map();
    this.blocks = new Map();
  }

  _createClass(BitswapMessage, [{
    key: 'addEntry',
    value: function addEntry(key, priority, cancel) {
      assert(Buffer.isBuffer(key), 'key must be a buffer');

      var e = this.wantlist.get(mh.toB58String(key));

      if (e) {
        e.priority = priority;
        e.cancel = Boolean(cancel);
      } else {
        this.wantlist.set(mh.toB58String(key), new Entry(key, priority, cancel));
      }
    }
  }, {
    key: 'addBlock',
    value: function addBlock(block) {
      this.blocks.set(mh.toB58String(block.key), block);
    }
  }, {
    key: 'cancel',
    value: function cancel(key) {
      this.wantlist.delete(mh.toB58String(key));
      this.addEntry(key, 0, true);
    }
  }, {
    key: 'toProto',
    value: function toProto() {
      var msg = {
        wantlist: {
          entries: Array.from(this.wantlist.values()).map(function (e) {
            return {
              block: e.key,
              priority: Number(e.priority),
              cancel: Boolean(e.cancel)
            };
          })
        },
        blocks: Array.from(this.blocks.values()).map(function (b) {
          return b.data;
        })
      };

      if (this.full) {
        msg.wantlist.full = true;
      }

      return pbm.Message.encode(msg);
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      var cmp = function cmp(a, b) {
        if (a.equals && typeof a.equals === 'function') {
          return a.equals(b);
        }
      };

      if (this.full !== other.full || !isEqualWith(this.wantlist, other.wantlist, cmp) || !isEqualWith(this.blocks, other.blocks, cmp)) {
        return false;
      }

      return true;
    }
  }, {
    key: 'empty',
    get: function get() {
      return this.blocks.size === 0 && this.wantlist.size === 0;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      var list = Array.from(this.wantlist.keys());
      var blocks = Array.from(this.blocks.keys());
      return 'BitswapMessage <full: ' + this.full + ', list: ' + list + ', blocks: ' + blocks + '>';
    }
  }]);

  return BitswapMessage;
}();

BitswapMessage.fromProto = function (raw) {
  var dec = pbm.Message.decode(raw);
  var m = new BitswapMessage(dec.wantlist.full);

  dec.wantlist.entries.forEach(function (e) {
    m.addEntry(e.block, e.priority, e.cancel);
  });
  dec.blocks.forEach(function (b) {
    return m.addBlock(new Block(b));
  });

  return m;
};

BitswapMessage.Entry = Entry;
module.exports = BitswapMessage;