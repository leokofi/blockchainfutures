'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = require('debug');
var mh = require('multihashes');
var pull = require('pull-stream');
var generate = require('pull-generate');

var log = debug('bitswap:engine');
log.error = debug('bitswap:engine:error');

var Message = require('../message');
var Wantlist = require('../wantlist');
var PeerRequestQueue = require('./peer-request-queue');
var Ledger = require('./ledger');

module.exports = function () {
  function Engine(blockstore, network) {
    _classCallCheck(this, Engine);

    this.blockstore = blockstore;
    this.network = network;

    // A list of of ledgers by their partner id
    this.ledgerMap = new Map();

    // A priority queue of requests received from different
    // peers.
    this.peerRequestQueue = new PeerRequestQueue();

    this._running = false;
  }

  _createClass(Engine, [{
    key: '_sendBlock',
    value: function _sendBlock(env, cb) {
      var msg = new Message(false);
      msg.addBlock(env.block);

      log('Sending block to %s', env.peer.toB58String(), env.block.data.toString());

      this.network.sendMessage(env.peer, msg, function (err) {
        if (err) {
          log('sendblock error: %s', err.message);
        }
        cb(null, 'done');
      });
    }
  }, {
    key: '_outbox',
    value: function _outbox() {
      var _this = this;

      if (!this._running) return;

      var doIt = function doIt(cb) {
        return pull(generate(null, function (state, cb) {
          log('generating', _this._running);
          if (!_this._running) {
            return cb(true);
          }

          var nextTask = _this.peerRequestQueue.pop();
          log('got task', nextTask);
          if (!nextTask) {
            return cb(true);
          }

          pull(_this.blockstore.getStream(nextTask.entry.key), pull.collect(function (err, blocks) {
            log('generated', blocks);
            var block = blocks[0];
            if (err || !block) {
              nextTask.done();
              return cb(null, false);
            }

            cb(null, {
              peer: nextTask.target,
              block: block,
              sent: function sent() {
                nextTask.done();
              }
            });
          }));
        }), pull.filter(Boolean), pull.asyncMap(_this._sendBlock.bind(_this)), pull.onEnd(cb));
      };

      if (!this._timer) {
        this._timer = setTimeout(function () {
          doIt(function () {
            _this._timer = null;
          });
        }, 50);
      }
    }
  }, {
    key: 'wantlistForPeer',
    value: function wantlistForPeer(peerId) {
      if (!this.ledgerMap.has(peerId.toB58String())) {
        return new Map();
      }

      return this.ledgerMap.get(peerId.toB58String()).wantlist.sortedEntries();
    }
  }, {
    key: 'peers',
    value: function peers() {
      return Array.from(this.ledgerMap.values()).map(function (l) {
        return l.partner;
      });
    }

    // Handle incoming messages

  }, {
    key: 'messageReceived',
    value: function messageReceived(peerId, msg, cb) {
      var _this2 = this;

      var ledger = this._findOrCreate(peerId);

      if (msg.empty) {
        log('received empty message from %s', peerId.toB58String());
        return cb();
      }

      // If the message was a full wantlist clear the current one
      if (msg.full) {
        ledger.wantlist = new Wantlist();
      }

      this._processBlocks(msg.blocks, ledger);
      log('wantlist', Array.from(msg.wantlist.values()).map(function (e) {
        return e.toString();
      }));

      pull(pull.values(Array.from(msg.wantlist.values())), pull.asyncMap(function (entry, cb) {
        _this2._processWantlist(ledger, peerId, entry, cb);
      }), pull.onEnd(function (err) {
        if (err) return cb(err);
        _this2._outbox();
        cb();
      }));
    }
  }, {
    key: 'receivedBlock',
    value: function receivedBlock(key) {
      this._processBlock(key);
      this._outbox();
    }
  }, {
    key: '_processBlock',
    value: function _processBlock(key) {
      // Check all connected peers if they want the block we received
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.ledgerMap.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var l = _step.value;

          var entry = l.wantlistContains(key);

          if (entry) {
            this.peerRequestQueue.push(entry, l.partner);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: '_processWantlist',
    value: function _processWantlist(ledger, peerId, entry, cb) {
      var _this3 = this;

      if (entry.cancel) {
        log('cancel %s', mh.toB58String(entry.key));
        ledger.cancelWant(entry.key);
        this.peerRequestQueue.remove(entry.key, peerId);
        setImmediate(function () {
          return cb();
        });
      } else {
        log('wants %s - %s', mh.toB58String(entry.key), entry.priority);
        ledger.wants(entry.key, entry.priority);

        // If we already have the block, serve it
        this.blockstore.has(entry.key, function (err, exists) {
          if (err) {
            log('failed existence check %s', mh.toB58String(entry.key));
          } else if (exists) {
            log('has want %s', mh.toB58String(entry.key));
            _this3.peerRequestQueue.push(entry.entry, peerId);
          }
          cb();
        });
      }
    }
  }, {
    key: '_processBlocks',
    value: function _processBlocks(blocks, ledger) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = blocks.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var block = _step2.value;

          log('got block %s (%s bytes)', mh.toB58String(block.key), block.data.length);
          ledger.receivedBytes(block.data.length);

          this.receivedBlock(block.key);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    // Clear up all accounting things after message was sent

  }, {
    key: 'messageSent',
    value: function messageSent(peerId, msg) {
      var ledger = this._findOrCreate(peerId);
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = msg.blocks.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var block = _step3.value;

          ledger.sentBytes(block.data.length);
          ledger.wantlist.remove(block.key);
          this.peerRequestQueue.remove(block.key, peerId);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: 'numBytesSentTo',
    value: function numBytesSentTo(peerId) {
      return this._findOrCreate(peerId).accounting.bytesSent;
    }
  }, {
    key: 'numBytesReceivedFrom',
    value: function numBytesReceivedFrom(peerId) {
      return this._findOrCreate(peerId).accounting.bytesRecv;
    }
  }, {
    key: 'peerDisconnected',
    value: function peerDisconnected(peerId) {
      // if (this.ledgerMap.has(peerId.toB58String())) {
      //   this.ledgerMap.delete(peerId.toB58String())
      // }
      //
      // TODO: figure out how to remove all other references
      // in the peerrequestqueue
    }
  }, {
    key: '_findOrCreate',
    value: function _findOrCreate(peerId) {
      if (this.ledgerMap.has(peerId.toB58String())) {
        return this.ledgerMap.get(peerId.toB58String());
      }

      var l = new Ledger(peerId);
      this.ledgerMap.set(peerId.toB58String(), l);

      return l;
    }
  }, {
    key: 'start',
    value: function start() {
      this._running = true;
    }
  }, {
    key: 'stop',
    value: function stop() {
      this._running = false;
    }
  }]);

  return Engine;
}();