'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = require('debug');
var pull = require('pull-stream');
var mh = require('multihashes');

var Message = require('../message');
var Wantlist = require('../wantlist');
var cs = require('../constants');
var MsgQueue = require('./msg-queue');

var log = debug('bitswap:wantmanager');
log.error = debug('bitswap:wantmanager:error');

module.exports = function () {
  function Wantmanager(network) {
    _classCallCheck(this, Wantmanager);

    this.peers = new Map();
    this.wl = new Wantlist();

    this.network = network;
  }

  _createClass(Wantmanager, [{
    key: '_newMsgQueue',
    value: function _newMsgQueue(peerId) {
      return new MsgQueue(peerId, this.network);
    }
  }, {
    key: '_addEntries',
    value: function _addEntries(keys, cancel, force) {
      var _this = this;

      var i = -1;
      pull(pull.values(keys), pull.map(function (key) {
        i++;
        return new Message.Entry(key, cs.kMaxPriority - i, cancel);
      }), pull.through(function (e) {
        // add changes to our wantlist
        if (e.cancel) {
          if (force) {
            _this.wl.removeForce(e.key);
          } else {
            _this.wl.remove(e.key);
          }
        } else {
          log('adding to wl', mh.toB58String(e.key), e.priority);
          _this.wl.add(e.key, e.priority);
        }
      }), pull.collect(function (err, entries) {
        if (err) throw err;
        // broadcast changes
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _this.peers.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var p = _step.value;

            p.addEntries(entries, false);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }));
    }
  }, {
    key: '_startPeerHandler',
    value: function _startPeerHandler(peerId) {
      var mq = this.peers.get(peerId.toB58String());

      if (mq) {
        mq.refcnt++;
        return;
      }

      mq = this._newMsgQueue(peerId);

      // new peer, give them the full wantlist
      var fullwantlist = new Message(true);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.wl.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var entry = _step2.value;

          fullwantlist.addEntry(entry[1].key, entry[1].priority);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      mq.addMessage(fullwantlist);

      this.peers.set(peerId.toB58String(), mq);
      mq.run();
      return mq;
    }
  }, {
    key: '_stopPeerHandler',
    value: function _stopPeerHandler(peerId) {
      var mq = this.peers.get(peerId.toB58String());

      if (!mq) {
        return;
      }

      mq.refcnt--;
      if (mq.refcnt > 0) {
        return;
      }

      mq.stop();
      this.peers.delete(peerId.toB58String());
    }

    // add all the keys to the wantlist

  }, {
    key: 'wantBlocks',
    value: function wantBlocks(keys) {
      log('want blocks:', keys.map(function (k) {
        return mh.toB58String(k);
      }));
      this._addEntries(keys, false);
    }

    // remove blocks of all the given keys without respecting refcounts

  }, {
    key: 'unwantBlocks',
    value: function unwantBlocks(keys) {
      log('unwant blocks:', keys.map(function (k) {
        return mh.toB58String(k);
      }));
      this._addEntries(keys, true, true);
    }

    // cancel wanting all of the given keys

  }, {
    key: 'cancelWants',
    value: function cancelWants(keys) {
      log('cancel wants: ', keys.map(function (k) {
        return mh.toB58String(k);
      }));
      this._addEntries(keys, true);
    }

    // Returns a list of all currently connected peers

  }, {
    key: 'connectedPeers',
    value: function connectedPeers() {
      return Array.from(this.peers.keys());
    }
  }, {
    key: 'connected',
    value: function connected(peerId) {
      log('peer connected: %s', peerId.toB58String());
      this._startPeerHandler(peerId);
    }
  }, {
    key: 'disconnected',
    value: function disconnected(peerId) {
      log('peer disconnected: %s', peerId.toB58String());
      this._stopPeerHandler(peerId);
    }
  }, {
    key: 'run',
    value: function run() {
      // TODO: is this needed? if so enable it
      //     // resend entirew wantlist every so often
      //     const es = []
      //     for (let e of this.wl.entries()) {
      //       es.push(new Message.Entry(e.key, e.priority))
      //     }

      //     this.peers.forEach((p) => {
      //       p.addEntries(es, true)
      //     })
      //     timer.start()
      //   }
      // }
    }
  }, {
    key: 'stop',
    value: function stop() {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.peers.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var mq = _step3.value;

          this.disconnected(mq.p);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }]);

  return Wantmanager;
}();