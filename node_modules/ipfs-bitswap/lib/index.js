'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var series = require('async/series');
var retry = require('async/retry');
var debug = require('debug');
var log = debug('bitswap');
log.error = debug('bitswap:error');
var EventEmitter = require('events').EventEmitter;
var mh = require('multihashes');
var pull = require('pull-stream');
var paramap = require('pull-paramap');
var defer = require('pull-defer/source');

var cs = require('./constants');
var WantManager = require('./wantmanager');
var Network = require('./network');
var decision = require('./decision');

module.exports = function () {
  function Bitwap(p, libp2p, blockstore, peerBook) {
    _classCallCheck(this, Bitwap);

    // the ID of the peer to act on behalf of
    this.self = p;

    // the network delivers messages
    this.network = new Network(libp2p, peerBook, this);

    // local database
    this.blockstore = blockstore;

    this.engine = new decision.Engine(blockstore, this.network);

    // handle message sending
    this.wm = new WantManager(this.network);

    this.blocksRecvd = 0;
    this.dupBlocksRecvd = 0;
    this.dupDataRecvd = 0;

    this.notifications = new EventEmitter();
    this.notifications.setMaxListeners(cs.maxListeners);
  }

  // handle messages received through the network


  _createClass(Bitwap, [{
    key: '_receiveMessage',
    value: function _receiveMessage(peerId, incoming, cb) {
      var _this = this;

      cb = cb || function () {};
      log('receiving message from %s', peerId.toB58String());
      this.engine.messageReceived(peerId, incoming, function (err) {
        if (err) {
          log('failed to receive message', incoming);
        }

        var iblocks = Array.from(incoming.blocks.values());

        if (iblocks.length === 0) {
          return cb();
        }

        // quickly send out cancels, reduces chances of duplicate block receives

        pull(pull.values(iblocks), pull.map(function (block) {
          return block.key;
        }), pull.filter(function (key) {
          return _this.wm.wl.contains(key);
        }), pull.collect(function (err, keys) {
          if (err) {
            return log.error(err);
          }
          _this.wm.cancelWants(keys);
        }));

        pull(pull.values(iblocks), paramap(_this._handleReceivedBlock.bind(_this, peerId), 10), pull.onEnd(cb));
      });
    }
  }, {
    key: '_handleReceivedBlock',
    value: function _handleReceivedBlock(peerId, block, cb) {
      var _this2 = this;

      log('handling block', block);
      series([function (cb) {
        return _this2._updateReceiveCounters(block, function (err) {
          if (err) {
            // ignore, as these have been handled
            // in _updateReceiveCounters
            return cb();
          }

          log('got block from %s', peerId.toB58String(), block.data.toString());
          cb();
        });
      }, function (cb) {
        return _this2.put(block, function (err) {
          if (err) {
            log.error('receiveMessage put error: %s', err.message);
          }
          cb();
        });
      }], cb);
    }
  }, {
    key: '_updateReceiveCounters',
    value: function _updateReceiveCounters(block, cb) {
      var _this3 = this;

      this.blocksRecvd++;
      this.blockstore.has(block.key, function (err, has) {
        if (err) {
          log('blockstore.has error: %s', err.message);
          return cb(err);
        }

        if (has) {
          _this3.dupBlocksRecvd++;
          _this3.dupDataRecvd += block.data.length;
          return cb(new Error('Already have block'));
        }

        cb();
      });
    }
  }, {
    key: '_tryPutBlock',
    value: function _tryPutBlock(block, times, cb) {
      var _this4 = this;

      log('trying to put block %s', block.data.toString());
      retry({ times: times, interval: 400 }, function (done) {
        pull(pull.values([block]), _this4.blockstore.putStream(), pull.onEnd(done));
      }, cb);
    }

    // handle errors on the receiving channel

  }, {
    key: '_receiveError',
    value: function _receiveError(err) {
      log.error('ReceiveError: %s', err.message);
    }

    // handle new peers

  }, {
    key: '_onPeerConnected',
    value: function _onPeerConnected(peerId) {
      this.wm.connected(peerId);
    }

    // handle peers being disconnected

  }, {
    key: '_onPeerDisconnected',
    value: function _onPeerDisconnected(peerId) {
      this.wm.disconnected(peerId);
      this.engine.peerDisconnected(peerId);
    }

    // return the current wantlist for a given `peerId`

  }, {
    key: 'wantlistForPeer',
    value: function wantlistForPeer(peerId) {
      return this.engine.wantlistForPeer(peerId);
    }
  }, {
    key: 'getStream',
    value: function getStream(keys) {
      var _this5 = this;

      if (!Array.isArray(keys)) {
        return this._getStreamSingle(keys);
      }

      return pull(pull.values(keys), paramap(function (key, cb) {
        pull(_this5._getStreamSingle(key), pull.collect(cb));
      }), pull.flatten());
    }
  }, {
    key: '_getStreamSingle',
    value: function _getStreamSingle(key) {
      var _this6 = this;

      var unwantListeners = {};
      var blockListeners = {};
      var unwantEvent = function unwantEvent(key) {
        return 'unwant:' + key;
      };
      var blockEvent = function blockEvent(key) {
        return 'block:' + key;
      };
      var d = defer();

      var cleanupListener = function cleanupListener(key) {
        var keyS = mh.toB58String(key);

        if (unwantListeners[keyS]) {
          _this6.notifications.removeListener(unwantEvent(keyS), unwantListeners[keyS]);
          delete unwantListeners[keyS];
        }

        if (blockListeners[keyS]) {
          _this6.notifications.removeListener(blockEvent(keyS), blockListeners[keyS]);
          delete blockListeners[keyS];
        }
      };

      var addListener = function addListener(key) {
        var keyS = mh.toB58String(key);
        unwantListeners[keyS] = function () {
          log('manual unwant: ' + keyS);
          cleanupListener(key);
          _this6.wm.cancelWants([key]);
          d.resolve(pull.empty());
        };

        blockListeners[keyS] = function (block) {
          _this6.wm.cancelWants([block.key]);
          cleanupListener(key);
          d.resolve(pull.values([block]));
        };

        _this6.notifications.once(unwantEvent(keyS), unwantListeners[keyS]);
        _this6.notifications.once(blockEvent(keyS), blockListeners[keyS]);
      };

      this.blockstore.has(key, function (err, exists) {
        if (err) {
          return d.resolve(pull.error(err));
        }
        if (exists) {
          return d.resolve(_this6.blockstore.getStream(key));
        }

        addListener(key);
        _this6.wm.wantBlocks([key]);
      });

      return d;
    }

    // removes the given keys from the want list independent of any ref counts

  }, {
    key: 'unwant',
    value: function unwant(keys) {
      var _this7 = this;

      if (!Array.isArray(keys)) {
        keys = [keys];
      }

      this.wm.unwantBlocks(keys);
      keys.forEach(function (key) {
        _this7.notifications.emit('unwant:' + mh.toB58String(key));
      });
    }

    // removes the given keys from the want list

  }, {
    key: 'cancelWants',
    value: function cancelWants(keys) {
      if (!Array.isArray(keys)) {
        keys = [keys];
      }
      this.wm.cancelWants(keys);
    }
  }, {
    key: 'putStream',
    value: function putStream() {
      var _this8 = this;

      return pull(pull.asyncMap(function (block, cb) {
        _this8.blockstore.has(block.key, function (err, exists) {
          if (err) return cb(err);
          cb(null, [block, exists]);
        });
      }), pull.filter(function (val) {
        return !val[1];
      }), pull.map(function (val) {
        var block = val[0];

        return pull(pull.values([block]), _this8.blockstore.putStream(), pull.through(function (meta) {
          var key = block.key;
          log('put block: %s', mh.toB58String(key));
          _this8.notifications.emit('block:' + mh.toB58String(key), block);
          _this8.engine.receivedBlock(key);
        }));
      }), pull.flatten());
    }

    // announces the existance of a block to this service

  }, {
    key: 'put',
    value: function put(block, cb) {
      pull(pull.values([block]), this.putStream(), pull.onEnd(cb));
    }
  }, {
    key: 'getWantlist',
    value: function getWantlist() {
      return this.wm.wl.entries();
    }
  }, {
    key: 'stat',
    value: function stat() {
      return {
        wantlist: this.getWantlist(),
        blocksReceived: this.blocksRecvd,
        dupBlksReceived: this.dupBlocksRecvd,
        dupDataReceived: this.dupDataRecvd,
        peers: this.engine.peers()
      };
    }
  }, {
    key: 'start',
    value: function start() {
      this.wm.run();
      this.network.start();
      this.engine.start();
    }

    // Halt everything

  }, {
    key: 'stop',
    value: function stop() {
      this.wm.stop();
      this.network.stop();
      this.engine.stop();
    }
  }]);

  return Bitwap;
}();