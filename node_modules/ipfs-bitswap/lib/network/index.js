'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = require('debug');
var lp = require('pull-length-prefixed');
var pull = require('pull-stream');

var Message = require('../message');
var cs = require('../constants');
var log = debug('bitswap:network');

var PROTOCOL_IDENTIFIER = '/ipfs/bitswap/1.0.0';

module.exports = function () {
  function Network(libp2p, peerBook, bitswap) {
    _classCallCheck(this, Network);

    this.libp2p = libp2p;
    this.peerBook = peerBook;
    this.bitswap = bitswap;

    // increase event listener max
    this.libp2p.swarm.setMaxListeners(cs.maxListeners);
  }

  _createClass(Network, [{
    key: 'start',
    value: function start() {
      var _this = this;

      // bind event listeners
      this._onConnection = this._onConnection.bind(this);
      this._onPeerMux = this._onPeerMux.bind(this);
      this._onPeerMuxClosed = this._onPeerMuxClosed.bind(this);

      this.libp2p.handle(PROTOCOL_IDENTIFIER, this._onConnection);

      this.libp2p.swarm.on('peer-mux-established', this._onPeerMux);

      this.libp2p.swarm.on('peer-mux-closed', this._onPeerMuxClosed);

      // All existing connections are like new ones for us
      var pKeys = Object.keys(this.peerBook.getAll());
      pKeys.forEach(function (k) {
        _this._onPeerMux(_this.peerBook.getByB58String(k));
      });
    }
  }, {
    key: 'stop',
    value: function stop() {
      this.libp2p.unhandle(PROTOCOL_IDENTIFIER);
      this.libp2p.swarm.removeListener('peer-mux-established', this._onPeerMux);

      this.libp2p.swarm.removeListener('peer-mux-closed', this._onPeerMuxClosed);
    }
  }, {
    key: '_onConnection',
    value: function _onConnection(conn) {
      var _this2 = this;

      log('incomming new bitswap connection');
      pull(conn, lp.decode(), pull.through(function (data) {
        var msg = void 0;
        try {
          msg = Message.fromProto(data);
        } catch (err) {
          return _this2.bitswap._receiveError(err);
        }
        conn.getPeerInfo(function (err, peerInfo) {
          if (err) {
            return _this2.bitswap._receiveError(err);
          }
          _this2.bitswap._receiveMessage(peerInfo.id, msg);
        });
      }), pull.onEnd(function (err) {
        if (err) {
          return _this2.bitswap._receiveError(err);
        }
      }));
    }
  }, {
    key: '_onPeerMux',
    value: function _onPeerMux(peerInfo) {
      this.bitswap._onPeerConnected(peerInfo.id);
    }
  }, {
    key: '_onPeerMuxClosed',
    value: function _onPeerMuxClosed(peerInfo) {
      this.bitswap._onPeerDisconnected(peerInfo.id);
    }

    // Connect to the given peer

  }, {
    key: 'connectTo',
    value: function connectTo(peerId, cb) {
      log('connecting to %s', peerId.toB58String());
      var done = function done(err) {
        return setImmediate(function () {
          return cb(err);
        });
      };
      // NOTE: For now, all this does is ensure that we are
      // connected. Once we have Peer Routing, we will be able
      // to find the Peer
      if (this.libp2p.swarm.muxedConns[peerId.toB58String()]) {
        done();
      } else {
        done(new Error('Could not connect to peer with peerId:', peerId.toB58String()));
      }
    }

    // Send the given msg (instance of Message) to the given peer

  }, {
    key: 'sendMessage',
    value: function sendMessage(peerId, msg, cb) {
      log('sendMessage to %s', peerId.toB58String());
      log('msg', msg);
      var peerInfo = void 0;
      try {
        peerInfo = this.peerBook.getByMultihash(peerId.toBytes());
      } catch (err) {
        return cb(err);
      }

      this.libp2p.dialByPeerInfo(peerInfo, PROTOCOL_IDENTIFIER, function (err, conn) {
        log('dialed %s', peerInfo.id.toB58String(), err);
        if (err) {
          return cb(err);
        }
        pull(pull.values([msg.toProto()]), lp.encode(), conn);
        cb();
      });
    }
  }]);

  return Network;
}();