'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assert = require('assert');

var stores = require('./stores');

module.exports = function () {
  function Repo(repoPath, options) {
    var _this = this;

    _classCallCheck(this, Repo);

    assert.equal(typeof repoPath === 'undefined' ? 'undefined' : _typeof(repoPath), 'string', 'missing repoPath');
    assert(options, 'missing options');
    assert(options.stores, 'missing options.stores');

    this.path = repoPath;

    var blobStores = initializeBlobStores(options.stores);

    var setup = function setup(name, needs) {
      needs = needs || {};
      var args = [repoPath, blobStores[name]];
      if (needs.locks) {
        args.push(_this.locks);
      }

      if (needs.config) {
        args.push(_this.config);
      }

      return stores[name].setUp.apply(stores[name], args);
    };

    this.locks = setup('locks');
    this.version = setup('version', { locks: true });
    this.config = setup('config', { locks: true });
    this.keys = setup('keys', { locks: true, config: true });
    this.blockstore = setup('blockstore', { locks: true });
  }

  _createClass(Repo, [{
    key: 'exists',
    value: function exists(callback) {
      this.version.exists(callback);
    }
  }]);

  return Repo;
}();

function initializeBlobStores(store) {
  if (store.constructor) {
    return {
      keys: store,
      config: store,
      blockstore: store,
      logs: store,
      locks: store,
      version: store
    };
  }

  return store;
}