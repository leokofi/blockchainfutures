'use strict';

var Block = require('ipfs-block');
var pull = require('pull-stream');
var Lock = require('lock');
var base32 = require('base32.js');
var path = require('path');
var write = require('pull-write');
var parallel = require('run-parallel');
var defer = require('pull-defer/source');

var PREFIX_LENGTH = 5;

exports = module.exports;

function multihashToPath(multihash, extension) {
  extension = extension || 'data';
  var encoder = new base32.Encoder();
  var hash = encoder.write(multihash).finalize();
  var filename = hash + '.' + extension;
  var folder = filename.slice(0, PREFIX_LENGTH);

  return path.join(folder, filename);
}

exports.setUp = function (basePath, BlobStore, locks) {
  var store = new BlobStore(basePath + '/blocks');
  var lock = new Lock();

  function writeBlock(block, cb) {
    if (!block || !block.data) {
      return cb(new Error('Invalid block'));
    }

    var key = multihashToPath(block.key, block.extension);

    lock(key, function (release) {
      return pull(pull.values([block.data]), store.write(key, release(function (err) {
        if (err) {
          return cb(err);
        }
        cb(null, { key: key });
      })));
    });
  }

  return {
    getStream: function getStream(key, extension) {
      if (!key) {
        return pull.error(new Error('Invalid key'));
      }

      var p = multihashToPath(key, extension);
      var deferred = defer();

      lock(p, function (release) {
        var ext = extension === 'data' ? 'protobuf' : extension;
        pull(store.read(p), pull.collect(release(function (err, data) {
          if (err) {
            return deferred.abort(err);
          }

          deferred.resolve(pull.values([new Block(Buffer.concat(data), ext)]));
        })));
      });

      return deferred;
    },
    putStream: function putStream() {
      var ended = false;
      var written = [];
      var push = null;

      var sink = write(function (blocks, cb) {
        parallel(blocks.map(function (block) {
          return function (cb) {
            writeBlock(block, function (err, meta) {
              if (err) {
                return cb(err);
              }

              if (push) {
                var read = push;
                push = null;
                read(null, meta);
                return cb();
              }

              written.push(meta);
              cb();
            });
          };
        }), cb);
      }, null, 100, function (err) {
        ended = err || true;
        if (push) push(ended);
      });

      var source = function source(end, cb) {
        if (end) ended = end;
        if (ended) {
          return cb(ended);
        }

        if (written.length) {
          return cb(null, written.shift());
        }

        push = cb;
      };

      return { source: source, sink: sink };
    },
    has: function has(key, extension, cb) {
      if (typeof extension === 'function') {
        cb = extension;
        extension = undefined;
      }

      if (!key) {
        return cb(new Error('Invalid key'));
      }

      var p = multihashToPath(key, extension);
      store.exists(p, cb);
    },
    delete: function _delete(key, extension, cb) {
      if (typeof extension === 'function') {
        cb = extension;
        extension = undefined;
      }

      if (!key) {
        return cb(new Error('Invalid key'));
      }

      var p = multihashToPath(key, extension);
      store.remove(p, cb);
    }
  };
};