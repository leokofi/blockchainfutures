'use strict';

var multiaddr = require('multiaddr');
var Connection = require('interface-connection').Connection;
var os = require('os');
var contains = require('lodash.contains');
var net = require('net');
var toPull = require('stream-to-pull-stream');
var EventEmitter = require('events').EventEmitter;
var debug = require('debug');
var log = debug('libp2p:tcp:listen');

var getMultiaddr = require('./get-multiaddr');

var IPFS_CODE = 421;
var CLOSE_TIMEOUT = 2000;

module.exports = function (handler) {
  var listener = new EventEmitter();

  var server = net.createServer(function (socket) {
    var addr = getMultiaddr(socket);
    log('new connection', addr.toString());

    var s = toPull.duplex(socket);
    s.getObservedAddrs = function (cb) {
      return cb(null, [addr]);
    };

    trackSocket(server, socket);

    var conn = new Connection(s);
    handler(conn);
    listener.emit('connection', conn);
  });

  server.on('listening', function () {
    listener.emit('listening');
  });

  server.on('error', function (err) {
    listener.emit('error', err);
  });

  server.on('close', function () {
    listener.emit('close');
  });

  // Keep track of open connections to destroy in case of timeout
  server.__connections = {};

  listener.close = function (options, cb) {
    if (typeof options === 'function') {
      cb = options;
      options = {};
    }
    cb = cb || function () {};
    options = options || {};

    var closed = false;
    server.close(cb);
    server.once('close', function () {
      closed = true;
    });
    setTimeout(function () {
      if (closed) return;

      log('unable to close graciously, destroying conns');
      Object.keys(server.__connections).forEach(function (key) {
        log('destroying %s', key);
        server.__connections[key].destroy();
      });
    }, options.timeout || CLOSE_TIMEOUT);
  };

  var ipfsId = void 0;
  var listeningAddr = void 0;

  listener.listen = function (ma, cb) {
    listeningAddr = ma;
    if (contains(ma.protoNames(), 'ipfs')) {
      ipfsId = getIpfsId(ma);
      listeningAddr = ma.decapsulate('ipfs');
    }

    var lOpts = listeningAddr.toOptions();
    log('Listening on %s %s', lOpts.port, lOpts.host);
    return server.listen(lOpts.port, lOpts.host, cb);
  };

  listener.getAddrs = function (cb) {
    var multiaddrs = [];
    var address = server.address();

    if (!address) {
      return cb(new Error('Listener is not ready yet'));
    }

    // Because TCP will only return the IPv6 version
    // we need to capture from the passed multiaddr
    if (listeningAddr.toString().indexOf('ip4') !== -1) {
      (function () {
        var m = listeningAddr.decapsulate('tcp');
        m = m.encapsulate('/tcp/' + address.port);
        if (ipfsId) {
          m = m.encapsulate('/ipfs/' + ipfsId);
        }

        if (m.toString().indexOf('0.0.0.0') !== -1) {
          (function () {
            var netInterfaces = os.networkInterfaces();
            Object.keys(netInterfaces).forEach(function (niKey) {
              netInterfaces[niKey].forEach(function (ni) {
                if (ni.family === 'IPv4') {
                  multiaddrs.push(multiaddr(m.toString().replace('0.0.0.0', ni.address)));
                }
              });
            });
          })();
        } else {
          multiaddrs.push(m);
        }
      })();
    }

    if (address.family === 'IPv6') {
      var ma = multiaddr('/ip6/' + address.address + '/tcp/' + address.port);
      if (ipfsId) {
        ma = ma.encapsulate('/ipfs/' + ipfsId);
      }

      multiaddrs.push(ma);
    }

    cb(null, multiaddrs);
  };

  return listener;
};

function getIpfsId(ma) {
  return ma.stringTuples().filter(function (tuple) {
    return tuple[0] === IPFS_CODE;
  })[0][1];
}

function trackSocket(server, socket) {
  var key = socket.remoteAddress + ':' + socket.remotePort;
  server.__connections[key] = socket;

  socket.on('close', function () {
    delete server.__connections[key];
  });
}